{"version":3,"sources":["components/udilia-logo.svg","serviceWorker.ts","../../node_modules/babel-plugin-transform-async-to-promises/helpers.js","../../src/roles-based-auth/context.ts","../../src/types.ts","../../src/authServices/TokenUtilities.ts","../../src/authServices/RequestWrapper.ts","../../src/authServices/BaseAuthApiWrapper.ts","../../src/components/Auth.tsx","../../src/components/RefreshApp.tsx","../../src/authServices/RequestBuilder.ts","../../src/components/SecureScreen.tsx","../../src/authServices/HeadersUtil.ts","../../src/utils/FetchWithTimeout.ts","components/Example.tsx","components/SecondExample.tsx","services/AppAuthContext.ts","components/Login.tsx","services/Utils.ts","components/Profile.tsx","components/LoginLogout.tsx","services/BrowserRefresh.tsx","services/SecureRoute.tsx","App.tsx","models/user.ts","services/Auth0Api.ts","services/AuthApi.ts","services/ExternalApi.ts","services/AppLocalStorage.ts","Main.tsx","index.tsx"],"names":["module","exports","Boolean","window","location","hostname","match","Symbol","iterator","asyncIterator","_catch","body","recover","result","e","then","RBAuthInitialUser","role","RBAuthInitialToken","accessToken","refreshToken","openIdToken","tokenType","expiresIn","scope","AuthContext","createContext","isAuth","reloading","user","logic","login","console","signup","logout","silent","handle","refresh","apis","routes","public","private","rules","static","admin","TokenUtil","setTokens","t","RBAuthErrors","RequestWrapper","recursion","accessTokenError","UNAUTHORIZED","refresTokenError","INVALID_GRANT","req","onFailure","Error","ApiAccessBuilder","success","failure","recursions","refreshTokenError","withAccessTokenError","this","withRefreshTokenError","withSuccess","withFailure","withCustomRecursions","build","dummyFunction","arg","Promise","r","BaseAuthApiWrapper","defaultLogin","defaultLogout","defaultSignupLogic","defaultSilentLogic","defaultHandleLogic","defaultRefreshLogic","loginLogic","logoutLogic","signupLogic","silentLogic","handleLogic","refreshLogic","errorCallback","appApis","args","res","runLogic","runRefresh","apiWrap","wrap","flag","finalizer","bind","authenticate","tokens","processes","embedWrapperLogicIntoApis","Object","item","setReloading","setUser","Auth","children","authApi","onAuthExpired","monitorUserChanges","React","useEffect","contextVal","value","FirstRun","RefreshApp","locationPathName","AuthReloadingComp","AuthLoadingComp","undefined","authCallbackRoute","debug","auth","useContext","useState","isReloading","setIsReloading","silentSwallow","SecureScreen","Redirect","Allowed","NotAllowed","to","HeadersBuilder","headers","withKeyValuePair","withContentTypeJson","withToken","type","withRBAuthToken","HTTPMethod","RequestBuilder","route","method","mode","errorHandling","timeout","withAuth0Body","withErrorHandling","withBody","withHeaders","withMethod","withMode","withTimeout","request","debugHeaders","JSON","requestInfo","opts","fetch","setTimeout","reject","contentType","Example","props","className","src","udiliaLogo","alt","width","Table","style","display","SecondExample","target","rel","href","AppAuthContext","Login","email","setEmail","password","setPassword","onChangeEvent","setter","val","onChange","onClick","twoDigits","str","length","Utils","date","month","getMonth","toString","day","getDate","hour","getHours","minutes","getMinutes","seconds","getSeconds","dateTime","getFullYear","join","clockTime","Logout","retrievedUser","setRetrievedUser","name","maxHeight","borderRadius","picture","nickname","catch","log","external","getUser","Date","lastFetched","LoginLogout","Consumer","BrowserRefresh","useLocation","pathname","AppRedirect","SecureRoute","path","render","Reloading","AppMenu","AppLink","label","App","anonUser","sub","updated_at","AUTH0_DOMAIN","process","AUTH0_CLIENT_ID","Auth0Api","rawTokens","access_token","refresh_token","id_token","expires_in","token_type","connection","auth0body","client_id","audience","authorize","username","POST","grant_type","error","a","getTokens","mapTokens","revoke","client_secret","token","device","GET","getUserInfo","userAuth0Id","AuthApi","authWrapper","userInfo","user_metadata","newUser","GlobalAppApi","AppStorage","setInitiated","tokensKey","setItem","key","localStorage","stringify","init","loadTokensFromStorage","getItem","parse","setStorage","valueToSave","AuthReloading","AuthLoading","Spinner","position","top","bottom","left","right","backgroundColor","flex","justifyContent","alignItems","Main","initiated","errorMsg","alert","ReactDOM","document","getElementById","navigator","serviceWorker","ready","registration","unregister","message"],"mappings":"wHAAAA,EAAOC,QAAU,IAA0B,yC,uLCavBC,QACW,cAA7BC,OAAOC,SAASC,UAEe,UAA7BF,OAAOC,SAASC,UAEhBF,OAAOC,SAASC,SAASC,MAAM,2D,oRCkJ4B,qBAAXC,SAA0BA,OAAOC,WAAaD,OAAOC,SAAWD,OAAO,qBA6DvD,qBAAXA,SAA0BA,OAAOE,gBAAkBF,OAAOE,cAAgBF,OAAO,0BAiVnI,SAASG,EAAOC,EAAMC,GAC5B,IACC,IAAIC,EAASF,IACZ,MAAMG,GACP,OAAOF,EAAQE,GAEhB,OAAID,GAAUA,EAAOE,KACbF,EAAOE,UAAK,EAAQH,GAErBC,ECpjBD,ICFP,EDEaG,EAA8D,CACzEC,KAAM,UAEKC,EAAuC,CAClDC,YADkD,GAElDC,aAFkD,GAGlDC,YAHkD,GAIlDC,UAJkD,GAKlDC,UALkD,GAMlDC,MAAO,IAGIC,EAAcC,wBAAiC,CAE1DC,QAF0D,EAG1DC,WAH0D,EAK1DC,KAL0D,EAO1DC,MAAO,CAELC,MAAO,WAAF,2BAAcC,YAAd,4DAELC,OAAQ,WAAF,2BAAcD,YAAd,6DAENE,OAAQ,WAAF,2BAAcF,YAAd,6DACNG,OAAQ,WAAF,2BAAcH,YAAd,6DAENI,OAAQ,WAAF,2BAAcJ,YAAd,6DACNK,QAAS,WAAF,2BAAcL,YAAd,8DACPM,KAAM,IAERC,OAAQ,CACNC,OADM,IAENC,QAAS,cAEXC,MAAO,CAELF,OAAQ,CACNG,OAAQ,CAAC,oBAGXC,MAAO,CACLD,OAAQ,CAAC,kBAAmB,4BEpCrBE,EAAb,6CAGE,YACEA,OAJJ,YASE,WACE,MAAO,CACL1B,YAAa0B,iBADR,GAELzB,aAAcyB,kBAFT,GAGLxB,YAAawB,iBAHR,GAILvB,UAAWuB,eAJN,GAKLtB,UAAWsB,eALN,GAMLrB,MAAOqB,WAAqB,KAhBlC,KACiBA,IAXyB,CACxC1B,YADwC,GAExCC,aAFwC,GAGxCC,YAHwC,GAIxCC,UAJwC,GAKxCC,UALwC,GAMxCC,MANwC,GAOxCsB,UAAW,yBAUJD,YAAY,4BAACE,MAAD,GAA8CF,cAA9C,IDhBrB,SAAKG,GACHA,gCACAA,8CACAA,6CACAA,8BACAA,wCACAA,sCACAA,oBAPF,CAAKA,MAAL,KEHA,IAQMC,a,uBAwCGb,OAAP,sBAYE,YARAc,UApDJ,QAqDIC,UAAmBH,EAAaI,mBAChCC,UAAmBL,EAAaM,eAMzB,yDACLL,wBADK,0C,EApDLA,GACWA,6CAKbC,MAdJ,GASiBD,I,YAMbE,UAAmBH,EAAaI,mBAChCC,UAAmBL,EAAaM,e,8BAG5B,uBAEIC,KAFJ,wBAIH,SAAQzC,GAAG,qCAcV,QAdU,oBACNA,eAAkCoC,GAD5B,uBAEJ,uBAEIb,KAFJ,6BAIKY,oBAA6DC,EAA7DD,IAJL,SAFI,WASN,MADAO,EAAUR,EAAVQ,uBACM,IAAIC,MAAMT,EAAhB,0BAGFQ,KAZQ,uCAdCP,oCAwDjB,IAAaS,EAAb,WAOE,cAAoB,KAAA5B,QANZ,KAAA6B,QAAyB,wBACzB,KAAAC,QAAyB,wBACzB,KAAAC,WApEV,EAqEU,KAAAV,iBAAiCH,EAAjC,cACA,KAAAc,kBAAkCd,EAAlC,sBALV,gDASEe,YAEE,OADAC,KAAA,mBACA,MAXJ,wBAcEC,YAEE,OADAD,KAAA,oBACA,MAhBJ,cAmBEE,YAEE,OADAF,KAAA,UACA,MArBJ,cAwBEG,YAEE,OADAH,KAAA,UACA,MA1BJ,uBA6BEI,YAEE,OADAJ,KAAA,aACA,MA/BJ,QAkCEK,YACE,OAAOpB,SACLe,KADKf,MAELe,KAFKf,QAGLe,KAHKf,QAILe,KAJKf,WAKLe,KALKf,iBAMLe,KANKf,mBAAP,IAnCJ,KCtBMqB,EAAgB,SAACC,GAAD,OAAkB,IAAIC,SAAiB,mBAAOC,EAAP,OAEhDC,EAAb,Y,cAoCE,sB,MAiBE,OAHA,0BA9BFC,aAAA,EACA,EAAAC,cAAA,EACA,EAAAC,mBAAA,EACA,EAAAC,mBAAA,EACA,EAAAC,mBAAA,EACA,EAAAC,oBAAA,EAEQ,EAAAC,WAAwB,EAAxB,aACA,EAAAC,YAA0B,EAA1B,cACA,EAAAC,YAA0B,EAA1B,mBACA,EAAAC,YAA0B,EAA1B,mBACA,EAAAC,YAA0B,EAA1B,mBACA,EAAAC,aAA4B,EAA5B,oBACA,EAAAC,cAAiD,wBACjD,EAAAC,QAAA,GAgCR,EAAAzD,MAAA,sCAAqD,WAAc,EAAd,yBAArD,gDACA,EAAAK,OAAA,sCAAsD,WAAc,EAAd,0BAAtD,gDACA,EAAAD,OAAA,sCAAsD,WAAc,EAAd,0BAAtD,gDAEA,EAAAF,OAA6B,wBAAkB,yBAAlB,YAE7B,EAAAI,QAAA,uCAAwD,aAAgB,EAAhB,cAAxD,wCACA,EAAAH,OAAA,sCAAuCuD,EAAvC,yBAAuCA,EAAvC,2CACE,uB,8BACoB,4CAAZC,G,uBACA,mCACN,eAHF,uCADF,oCAsBQ,EAAAC,SAAW,yDACdF,EADc,yBACdA,EADc,2CAMjB,uB,uBACoB3D,kCAAZ4D,G,uBAEA,oCACN,eAJF,uCANiB,qCAaX,EAAAE,WAAa,0DACnB,uB,uBACoB9D,KAAK,eAAjB4D,G,iBACN,GAAIA,EAAJ,oCAA4B7C,YAA5B,yB,uCACA,YAAO6C,KAHT,qCADmB,yCAQb,EAAAvC,iBAAmBH,EAAnB,aACA,EAAAc,kBAAoBd,EAApB,cAEA,EAAA6C,QAAU,mBAAgC,cAKhD,OAAO,IAAInC,EAAiB5B,GAArB,mDAGiB,EAHjB,wCAIkB,EAJlB,yBAKE,EALT,WAQM,EAAAgE,KAAA,uBAAiCC,OAAjC,O,OACN,GAAU,mB,gBL2YP,SAA0BpF,EAAMqF,GACtC,IACC,IAAInF,EAASF,IACZ,MAAOG,GACR,OAAOkF,GAAU,EAAMlF,GAExB,OAAID,GAAUA,EAAOE,KACbF,EAAOE,KAAKiF,EAAUC,KAAK,MAAM,GAAQD,EAAUC,KAAK,MAAM,IAE/DD,GAAU,EAAOnF,G,sBKlZNiB,YACNhB,GAWP,KATA,oBAAIA,UAAiC,gBAAmBkC,EAAnB,iBAArC,GAESlC,YAAckC,EAAlB,aAA6C,gBAA7C,GACIlC,YAAckC,EAAlB,2BAIIlC,YAAckC,EAAlB,2BACH,gBAAmBA,EAAnB,WACF,Q,iBAEA,GAAU,mB,uBAjBN,oCA2CA,EAAAkD,aAAA,qBACNR,MADM,U,MAMFA,GAAOA,EAAPA,MAAmBA,EAAIS,QACzB,UAAaT,EAAb,M,gBACM7C,YAAoB6C,EAApB7C,gCAEN,gB,gBACMA,sC,gEAXF,oCA5HN,IAAiC,mBACjC,IAAa,UAAe,4BAAf,IACb,GACIuD,EAAJ,QAAqB,aAAkBA,EAAlB,OACjBA,EAAJ,SAAsB,cAAmBA,EAAnB,QAClBA,EAAJ,SAAsB,cAAmBA,EAAnB,QAClBA,EAAJ,SAAsB,cAAmBA,EAAnB,QAClBA,EAAJ,SAAsB,cAAmBA,EAAnB,QAClBA,EAAJ,UAAuB,eAAoBA,EAApB,S,4HANP,IArDpB,O,EAAA,G,EAAA,G,sEAAA,sCAmFUC,Y,WACAxF,EAAN,GAQA,OAPAyF,wBAA0B,YACpBC,uBAA4BjE,EAA5BiE,IAAJ,oBAAqDjE,EAAP,GAC5CzB,KAAe,UAAayB,EAD9B,IAESA,aAAJ,kBAAkCA,EAAP,GAC9BzB,KAAe,4BAA+ByB,EAD3C,IAEAzB,KAAeyB,EAAfzB,MAEP,G,EA5FJ,G,EAAA,iBA8DE,WACE,OAAOmD,KAAP,a,2BA/DJ,IAPE,cAAmB,KAAAwC,eAAiC,KAAAC,aClCzCC,EAMR,SAAC,G,IAAEC,aAAUC,YAASrE,WAAQsE,kB,IAAerB,mBAAUA,EAAA,K,IAAIsB,8BAAqBA,EAAA,OACnF,EAAkCC,cAAlC,GAAOnF,EAAP,KAAkB4E,EAAlB,KACA,EAAwBO,aAAxB,MAAOlF,EAAP,KAAa4E,EAAb,KAEM3E,EAAQ,IAAI4C,EAAmB8B,EAAcC,EAASG,EAASC,EAArE,GAEAG,qBAAU,WACR,GAAwBF,OACvB,CAFHE,IAIA,IAAMC,EAAgC,CACpCtF,UAAWE,IAAQA,EAARA,MADyB,WACJA,QAChCD,UAFoC,EAGpCE,MAHoC,EAIpCS,OAAQ,CAAEE,SAAS,OAAAF,QAAM,IAANA,OAAA,EAAAA,EAAM,UAAjB,WAA0CC,QAAQ,OAAAD,QAAM,IAANA,OAAA,EAAAA,EAAM,SAAY,KAC5EV,KAAMA,GAL8B,EAMpCa,MAAO,CACLE,MADK,GAELJ,OAAQ,KAIZ,OAAO,kBAACf,EAAD,UAAsByF,MAAOD,GAApC,IC9BIE,eACUA,UAGhB,ICNA,EDMaC,EAMR,SAAC,G,IACJT,aACAU,qBACAC,sB,IACAC,2BAAkBA,OAAAC,IAClBC,sB,IACAC,iBAAQA,GAAA,EAEFC,EAAOC,qBAAb,GACA,EAAsCC,oBAAtC,GAAOC,EAAP,KAAoBC,EAApB,KAEAf,qBAAU,WACJW,kBAAJ,IAAsBJ,EAA+BQ,GAArD,GACKA,QACJ,CAACJ,EAAD,UAHHX,IAKA,IAAMgB,EAAgB,aAatB,OAXAhB,qBAAU,WACHG,EAAD,MAAkBE,IAAtB,IACEF,UAEA,GACEnF,sCACA2F,sBAAyB3F,QAAzB2F,WAA4C3F,QAA5C2F,MACKA,qCAPXX,KAWKG,EAAD,MAAJ,EAAgD,oBAAhD,MAGI,kBAAC,IAAD,cACGW,MAAkC,oBADrC,MADF,IExCSG,EAIR,SAAC,GAAD,IAAGC,EAAH,WAAaC,EAAb,UAAsBC,EAAtB,oBACH,kBAAC3G,EAAD,eACG,YACmB,MAAlB,OAAKkG,EAAL,OAKO,oBAAP,MAJE,EAAuB,oBAAP,MAET,qBAAUU,IAAI,UAAAV,EAAA,sCAAuB,UCbvCW,EAAb,WAEE,aACE,OAFF,KAAAC,QAAU,IAAV,QAEE,KAHJ,4CAMEC,cAEE,OADAxE,KAAA,oBACA,MARJ,sBAWEyE,WAEE,OADAzE,KAAA,kDACA,MAbJ,YAgBE0E,cAEE,OADA1E,KAAA,+BAAwC2E,EAAxC,OACA,MAlBJ,kBAqBEC,WAEE,OADA5E,KAAA,+BAAwCnB,cAAxC,cAA2EA,cAA3E,aACA,MAvBJ,QA0BEwB,WACE,OAAOL,KAAP,SA3BJ,MFAA,SAAY6E,GACVA,cACAA,YACAA,gBACAA,YACAA,kBACAA,cACAA,oBACAA,gBARF,CAAYA,MAAZ,KAcA,IAAaC,EAAb,WAUE,gBAEE,YAFiCpB,WAAQ,GAARA,aAT3B,KAAAqB,MAAA,GACA,KAAApI,KAAA,KACA,KAAA4H,QAAmB,IAAnB,QACA,KAAAS,OAAqBH,EAArB,IACA,KAAAI,KAAA,KAEA,KAAAC,cAAA,KACA,KAAAC,QGxBH,IH2BHnF,KAAA,QACA,KAZJ,yCAcEoF,YAEE,YAFYzI,UAAgC,IAC5CqD,KAAA,OACA,MAhBJ,oBAkBEqF,YAEE,OADArF,KAAA,gBACA,MApBJ,WAsBEsF,YAEE,YAFO3I,UAAgC,IACvCqD,KAAA,OACA,MAxBJ,cA0BEuF,YAEE,OADAvF,KAAA,UACA,MA5BJ,aA8BEwF,YAEE,OADAxF,KAAA,SACA,MAhCJ,WAkCEyF,YAEE,OADAzF,KAAA,OACA,MApCJ,cAsCE0F,YAEE,OADA1F,KAAA,UACA,MAxCJ,UA0CU2F,WACN,GAAI3F,KAAJ,MAAgB,CACd,IAAM4F,EAAN,GACA5F,KAAA,iBAAqB,qBAAiC4F,KAAjC,KAErB5H,6BAA8BgC,KAA9BhC,MAA0CgC,KAA1ChC,OAAuD6H,eAAvD7H,GAAqF6H,eAAe7F,KAApGhC,OAGF,IGhE6B8H,EAAD,IHgEtBC,EAAiF,CACrFf,OAAQhF,KAD6E,OAErFuE,QAASvE,KAAKuE,SAIhB,OAFIvE,KAAJ,OAAe+F,OAAY/F,KAAZ+F,MACX/F,KAAKgF,SAAWH,EAAhB,KAAkC7E,KAAKgF,SAAWH,EAAlD,MAAqE7E,KAAzE,OAAoF+F,EAAI,KAAWF,eAAe7F,KAA9B+F,OGrEvDD,EHsEL9F,KAAD,MGtEK,EHsEL,OGtEK,OHsEcA,KAA1C,WGtEkFmF,EAF/E,KAGL3E,QAAA,KAAgC,CAC9BwF,MAAMF,EADwB,GAE9B,IAAItF,SAAQ,qBAAeyF,YAAW,kBAAMC,EAAO,IAAIzG,MAAjB,cAA1B,SHWhB,uB,IA4DI,E,EACkBO,K,uBAAA,4BAAZ0B,G,aAKN,MAEE,MADI,EAAJ,eAAwB,mBAClBjC,MAAN,GAEF,SARA,IAAM0G,EAAczE,cAApB,gBACM/B,EAAU+B,EAAhB,G,EACIyE,IAAJ,IAAmBA,8BAAnB,gBAAkFzE,EAAlF,0BAAmE7E,OAAnE,gBACqB6E,EADrB,0BACK7E,O,kCAjET,MAAAC,GAAA,sBAAAA,KAAA,K,wBIZasJ,G,MAAoB,SAACC,GAAD,OAC/B,yBAAKC,UAAU,WACZD,EAAM1D,SACP,yBAAK4D,IAAKC,IAAYC,IAAI,aAAaC,MAAM,OAC7C,wBAAIJ,UAAU,gBAAd,oCCLEK,G,MAAkB,SAAC,GAAD,IAAGhE,EAAH,EAAGA,SAAH,OAAkB,yBAAKiE,MAAO,CAAEC,QAAS,SAAWlE,KAE/DmE,EAA0B,SAACT,GAAD,OACrC,yBAAKC,UAAU,iBACb,yBAAKA,UAAU,sBACb,kBAAC,EAAD,OAEF,uBACEA,UAAU,4BACVS,OAAO,SACPC,IAAI,sBACJC,KAAK,6EAJP,iBAQCZ,EAAM1D,WCFEuE,EAAiBzJ,ECZjB0J,EAAkB,WAC7B,IAAQrJ,EAAU8F,qBAAWsD,GAArBpJ,MACR,EAA0B+F,mBAAS,IAAnC,mBAAOuD,EAAP,KAAcC,EAAd,KACA,EAAgCxD,mBAAS,IAAzC,mBAAOyD,EAAP,KAAiBC,EAAjB,KAEMC,EACJ,SACEC,GADF,OAGA,SAACC,GAAD,OACED,EAAOC,EAAIX,OAAO7D,SAItB,OACE,6BACE,iDACA,4CACA,2BAAOA,MAAOkE,EAAOzC,KAAK,OAAOgD,SAAUH,EAAcH,KACzD,2BACEnE,MAAOoE,EACP3C,KAAK,WACLgD,SAAUH,EAAcD,KAE1B,4BAAQK,QAZG,kBAAM9J,EAAMC,MAAMqJ,EAAOE,KAYpC,WCxBN,SAASO,EAAUC,GACjB,MAAM,GAAN,OAAUA,EAAIC,OAAS,EAAI,IAAM,IAAjC,OAAsCD,GAGxC,IAeaE,EAfM,SAACC,GAClB,GAAa,OAATA,EAAe,MAAO,GAC1B,IAAMC,GAASD,EAAKE,WAAa,GAAGC,WAC9BC,EAAMJ,EAAKK,UAAUF,WACrBG,GAAQN,EAAKO,WAAa,GAAGJ,WAC7BK,GAAWR,EAAKS,aAAe,GAAGN,WAClCO,GAAWV,EAAKW,aAAe,GAAGR,WAIlCS,EAAW,CAFJZ,EAAKa,cAEMjB,EAAUK,GAAQL,EAAUQ,IAAMU,KAAK,KACzDC,EAAS,UAAMnB,EAAUU,GAAhB,YAAyBV,EAAUY,GAAnC,YAA+CZ,EAAUc,IACxE,MAAM,GAAN,OAAUE,EAAV,YAAsBG,ICTXC,EAAmB,WAC9B,IAAMtF,EAAOC,qBAAWsD,GAOxB,EAA0CrD,mBAAiC,MAA3E,mBAAOqF,EAAP,KAAsBC,EAAtB,KAeA,OACE,6BACE,6CACA,6CAAmBxF,EAAK9F,KAAKuL,MAC7B,yBACExC,MAAO,CAAEyC,UAAW,IAAKC,aAAc,IACvC/C,IAAK5C,EAAK9F,KAAK0L,QACf9C,IAAK9C,EAAK9F,KAAKuL,OAEjB,6CAAmBzF,EAAK9F,KAAK2L,UAC7B,4BAAQ5B,QA/BG,kBACbjE,EAAK7F,MACFI,SACAnB,MAAK,kBAAM,QACX0M,OAAM,kBAAM,UA2Bb,UACA,6BACE,4BAAQ7B,QAbE,kBAAMjE,EAAK7F,MAAMO,UAAUtB,KAAKiB,QAAQ0L,KAAKD,MAAMzL,QAAQ0L,OAarE,kBACA,4BAAQ9B,QA1BE,WACdjE,EAAK7F,MAAMQ,KAAKqL,SACbC,UACA7M,MAAK,SAAC2E,GAAD,OACJyH,EAAiB,CACfK,SAAY9H,EAAsC8H,SAClDvB,KAAM,IAAI4B,KACVC,aAA0B,OAAbZ,QAAa,IAAbA,OAAA,EAAAA,EAAejB,OAAQ,UAGvCwB,MAAMzL,QAAQ0L,OAgBb,YACCR,GACC,6BACE,0CACA,4BAAKA,EAAcM,UACnB,yDAEYxB,EAAiBkB,EAAcY,eAE3C,sDAEkB9B,EAAiBkB,EAAcjB,YCnDhD8B,EAAwB,kBAEnC,kBAAC7C,EAAe8C,SAAhB,MACG,SAACrG,GAAD,OACC,oCACGA,EAAKhG,QAAU,kBAAC,EAAD,OACdgG,EAAKhG,QAAU,kBAAC,EAAD,WCTZsM,EAGR,SAAC,GAAwD,IAAtDtH,EAAqD,EAArDA,SAAUW,EAA2C,EAA3CA,kBAAmBG,EAAwB,EAAxBA,kBAC7BrH,EAAW8N,cACjB,OACE,kBAAC,EAAD,CACE7G,iBAAkBjH,EAAS+N,SAC3B7G,kBAAmBA,EACnBG,kBAAmBA,GAElBd,ICPDyH,EAA8B,SAAC,GAAD,IAAG/F,EAAH,EAAGA,GAAH,OAAY,kBAAC,IAAD,CAAUA,GAAIA,KAEjDgG,EAIR,SAAC,GAAD,IAAGC,EAAH,EAAGA,KAAMnG,EAAT,EAASA,QAASC,EAAlB,EAAkBA,WAAlB,OACH,kBAAC,IAAD,CACEC,GAAIiG,EACJC,OAAQ,kBAAM,kBAAC,EAAD,CAAcpG,QAASA,EAASD,SAAUkG,EAAahG,WAAYA,QCR/EoG,EAAsB,kBAC1B,6BACE,4CACA,6BACA,+BAIEC,EAAoB,SAAC,GAAD,IAAG9H,EAAH,EAAGA,SAAH,OAAkB,yBAAK2D,UAAU,WAAW3D,IAChE+H,EAAmD,SAAC,GAAD,IAAGrG,EAAH,EAAGA,GAAIsG,EAAP,EAAOA,MAAP,OACvD,yBAAKrE,UAAU,WACb,kBAAC,IAAD,CAAMjC,GAAIA,GAAKsG,KAINC,EAAgB,kBAC3B,oCACE,kBAAC,EAAD,MACA,yBAAKtE,UAAU,uBACb,kBAAC,EAAD,KACE,kBAAC,EAAD,CAASjC,GAAG,IAAIsG,MAAM,SACtB,kBAAC,EAAD,CAAStG,GAAG,UAAUsG,MAAM,WAC5B,kBAAC,EAAD,CAAStG,GAAG,gBAAgBsG,MAAM,kBAEpC,kBAAC,EAAD,CAAgBrH,kBAAmBkH,GACjC,kBAAC,IAAD,KACE,kBAAC,EAAD,CACEF,KAAK,UACLnG,QAAS,kBAAM,4CACfC,WAAY,kBAAM,sDAGpB,kBAAC,EAAD,CAAakG,KAAK,gBAAgBnG,QAAS,kBAAM,qDAEnD,kBAAC,EAAD,QAIJ,kBAAC,EAAD,Q,qCCnCS0G,EAAsB,CACjCrB,SAAU,OACVJ,KAAM,GACNnM,KAAM,SACNsM,QACE,6HACFuB,IAAK,GACLC,WAAY,IAAIlB,M,QCVZmB,GAAeC,6BACfC,GAAkBD,mCAiBXE,GAAb,8FAQE,SAAiBC,GACf,MAAO,CACLjO,YAAaiO,EAAUC,aACvBjO,aAAcgO,EAAUE,cACxBjO,YAAa+N,EAAUG,SACvB/N,MAAO4N,EAAU5N,MACjBD,UAAW6N,EAAUI,WACrBlO,UAAW8N,EAAUK,gBAf3B,KAAaN,GACIO,WAAa,mCADjBP,GAII3N,MAAQ,gCAJZ2N,GAMIQ,UAAY,CAAEC,UAAWV,GAAiBW,SAtBpCZ,8CAgBVE,GAmBJW,UAAY,SAACC,EAAkBzE,GAAnB,OACjB,IAAIxC,EAAJ,kBAA8BkG,GAA9B,iBACGxF,WAAWX,EAAWmH,MACtBzG,aAAY,IAAIjB,GAAiBG,sBAAsBpE,SACvD+E,cAHH,2BAIO+F,GAASQ,WAJhB,IAKID,WAAYP,GAASO,WACrBlO,MAAO2N,GAAS3N,MAChByO,WAAY,WACZF,WACAzE,cAEDjC,mBAA6B,SAAC3D,GAC7B,GAAIA,EAAIwK,MAAO,MAAMzM,MAAMiC,EAAIwK,UAEhC7L,SAlCM8K,GAqCJ9M,Q,sBAAU,0CAAA8N,EAAA,0DACf/O,EADe,+BACQyB,EAAUuN,YAAYhP,eAEP,KAAjBA,EAHN,sBAGiC,IAAIqC,MAAM,kBAH3C,uBAIG,IAAIqF,EAAJ,kBAA8BkG,GAA9B,iBACfxF,WAAWX,EAAWmH,MACtBzG,aAAY,IAAIjB,GAAiBG,sBAAsBpE,SACvDiF,SAAS,CACR2G,WAAY,gBACZL,UAAWV,GACXI,cAAelO,IAEhBiI,mBAA6B,SAAC3D,GAC7B,GAAIA,EAAIwK,QAENlO,QAAQ0L,IAAI,mCAAoChI,EAAIwK,OAClC,kBAAdxK,EAAIwK,OAA2B,MAAMzM,MAAMT,EAAaM,kBAG/De,QAnBY,cAITqB,EAJS,yBAqBRyJ,GAASkB,UAAU3K,IArBX,2CArCNyJ,GA+DJjN,O,sBAAS,sBAAAiO,EAAA,+EACd,IAAIrH,EAAJ,kBAA8BkG,GAA9B,eAAwDvF,SAAS,WAAWpF,SAD9D,2CA/DL8K,GAkEJmB,OAAS,eAACnK,EAAD,uDAA4BtD,EAAUuN,YAAtC,OACdjK,EAAO/E,cACP,IAAI0H,EAAJ,kBAA8BkG,GAA9B,kBAA2D,GACxDxF,WAAWX,EAAWmH,MACtB1G,SAAS,CACRsG,UAAWV,GACXqB,cAAe,mEACfC,MAAOrK,EAAO/E,eAEfmI,aAAY,IAAIjB,GAAiBG,sBAAsBpE,SACvDoF,SAAS,WACTJ,mBAA6B,SAAC3D,GAC7B,GAAIA,EAAIwK,MAAO,MAAMzM,MAAMiC,EAAIwK,UAEhC7L,SAhFM8K,GAkFJlN,OAAS,SAACmL,EAAchC,EAAeE,GAA9B,OACd,IAAIxC,EAAJ,kBAA8BkG,GAA9B,0BACGxF,WAAWX,EAAWmH,MACtBzG,aAAY,IAAIjB,GAAiBG,sBAAsBpE,SACvD+E,cAHH,2BAIO+F,GAASQ,WAJhB,IAKID,WAAYP,GAASO,WACrBlO,MAAO2N,GAAS3N,MAChByO,WAAY,WACZQ,OAAQ,WACRrF,QACAgC,OACA9B,cAEDjC,mBAA6B,SAAC3D,GAC7B,GAAIA,EAAIwK,MAAO,MAAMzM,MAAMiC,EAAIwK,UAEhC7L,SAnGM8K,GAqGJvB,QAAU,SAAItM,EAAmBH,GAAvB,OACf,IAAI2H,EAAJ,kBAA8BkG,GAA9B,cACGxF,WAAWX,EAAW6H,KACtBnH,aAAY,IAAIjB,GAAiBI,UAAUpH,EAAWH,GAAakD,SACnEgF,mBAA6B,SAAC3D,GAC7B,GAAIA,EAAIwK,MAAO,MAAMzM,MAAMiC,EAAIwK,UAEhC7L,SA5GM8K,GA8GJwB,YAAc,SACnBrP,EACAH,EACAyP,GAHmB,OAKnB,IAAI9H,EAAJ,kBAA8BkG,GAA9B,yBAA2D4B,IACxDpH,WAAWX,EAAW6H,KACtBnH,aACC,IAAIjB,GAAiBI,UAAUpH,EAAWH,GAAasH,sBAAsBpE,SAE9EgF,mBAA6B,SAAC3D,GAC7B,GAAIA,EAAIwK,MAAO,MAAMzM,MAAMiC,EAAIwK,UAEhC7L,SC9GA,IAAMwM,GAAb,kCAAaA,GACJ9O,M,uCAAmB,WAAOgO,EAAkBzE,GAAzB,SAAA6E,EAAA,+EACxBU,GAAQC,YAAR,sBAAoB,sBAAAX,EAAA,kEAClBhB,GADkB,SACOA,GAASW,UAAUC,EAAUzE,GADpC,iDACT+E,UADS,8DADI,2C,wDADfQ,GAMJ1O,O,sBAAqB,sBAAAgO,EAAA,+EAC1BU,GAAQC,YAAR,sBAAoB,sBAAAX,EAAA,+EAAYU,GAAQxO,WAApB,6CADM,2CANjBwO,GAQJ3O,OAAS,kBAAMiN,GAASjN,UARpB2O,GASJ5O,OAAqB,SAACmL,EAAMhC,EAAOE,GAAd,OAC1B6D,GAASlN,OAAOmL,EAAMhC,EAAOE,IAVpBuF,GAWJxO,QAAU,kBAAM8M,GAAS9M,WAXrBwO,GAgBIC,Y,uCAAc,WAG3BV,GAH2B,uBAAAD,EAAA,+EASTC,IATS,cASnBrN,EATmB,gBAUNoM,GAASvB,QAC1B7K,EAAEzB,UACFyB,EAAE5B,aAZqB,cAUnBU,EAVmB,OAezBG,QAAQ0L,IAAI,SAAU7L,GAfG,UAkBFsN,GAASwB,YAC9B5N,EAAEzB,UACFyB,EAAE5B,YACFU,EAAKiN,KArBkB,eAkBnBiC,EAlBmB,OAwBzB/O,QAAQ0L,IAAI,aAAcqD,GAEtB9P,EAAO4N,EAAS5N,KAChB8P,GAAYA,EAASC,eAAiBD,EAASC,cAAc/P,OAC/DA,EAAO8P,EAASC,cAAc/P,MA5BP,kBA6BlB,CACLkF,OAAQpD,EACRlB,KAAK,2BACCA,GAAQgN,GADV,IAEF5N,WAjCqB,yCAsCzBe,QAAQ0L,IAAI,sBAAZ,MACMuD,EAAapC,EAvCM,kBAwClB,CACL1I,OAAQ,CACNhF,YAAa,GACbC,aAAc,GACdC,YAAa,GACbE,UAAW,GACXC,MAAO,GACPF,UAAW,IAEbO,KAAMoP,IAjDiB,0D,sDCtD/B,IAcaC,GAA8B,CACzCvD,SAAU,I,sCAZVC,QAAU,kBACR,IAAI9E,EAAJ,kBAJiBmG,6BAIjB,cACGzF,WAAWX,EAAW6H,KACtBnH,aAAY,IAAIjB,GAAiBM,kBAAkBvE,SACnDA,WCJM8M,GAAb,WASE,WAAYC,GAAwE,IAAjCC,EAAgC,uDAXlE,uBAWkE,yBARnFA,eAQmF,OAPnFlQ,YAAc,GAOqE,KANnFC,aAAe,GAMoE,KALnFC,YAAc,GAKqE,KAJnFC,UAAY,GAIuE,KAHnFC,UAAY,GAGuE,KAFnFC,MAAQ,GAE2E,KA6CnF8P,QA7CmF,uCA6CzE,WAAOC,GAAP,2BAAApB,EAAA,yDAAoBjJ,EAApB,+BAAoD,IAExDqK,IAAOrK,EAFH,yCAEiBsK,aAAaF,QAAQC,EAAK1H,KAAK4H,UAAUvK,KAF1D,4EA7CyE,sDACjFlD,KAAKqN,UAAYA,EACjBrN,KAAK0N,KAAKN,GAXd,+EAcE,WAAmBA,GAAnB,iEACEpN,KAAK2N,wBAAwB5Q,MAAK,kBAAMqQ,GAAa,MADvD,gDAdF,iIAkBE,uFACQhC,EAAYoC,aAAaI,QAAQ5N,KAAKqN,aAC3BjC,EAAUrD,OAAS,IAC5B5F,EAA2B0D,KAAKgI,MAAMzC,GAC5CpN,QAAQ0L,IAAI,+CAAgDvH,EAAO/E,cAEnE4C,KAAK5C,aAAe+E,EAAO/E,aAC3B4C,KAAK7C,YAAcgF,EAAOhF,YAC1B6C,KAAK3C,YAAc8E,EAAO9E,YAC1B2C,KAAKzC,UAAY4E,EAAO5E,UACxByC,KAAKxC,MAAQ2E,EAAO3E,MACpBwC,KAAK1C,UAAY6E,EAAO7E,WAG1BuB,EAAUiP,WAAW9N,MAdvB,gDAlBF,oHAmCE,WAAgBmC,GAAhB,eAAAgK,EAAA,sDACMhK,EAAOhF,cAAa6C,KAAK7C,YAAcgF,EAAOhF,aAC9CgF,EAAO5E,YAAWyC,KAAKzC,UAAY4E,EAAO5E,WAC1C4E,EAAO9E,cAAa2C,KAAK3C,YAAc8E,EAAO9E,aAC9C8E,EAAO7E,YAAW0C,KAAK1C,UAAY6E,EAAO7E,WAC1C6E,EAAO3E,QAAOwC,KAAKxC,MAAQ2E,EAAO3E,OAClC2E,EAAO/E,eAAc4C,KAAK5C,aAAe+E,EAAO/E,cAEpD,IAEQ2Q,EAAc,CAClB3Q,aAAc+E,EAAO/E,cAEvB4C,KAAKsN,QAAQtN,KAAKqN,UAAWU,GAC7B,MAAOjR,GACPkB,QAAQ0L,IAAI,uCAAwC5M,GAfxD,gDAnCF,8DCGMkR,GAA0B,kBAC9B,kBAAC,GAAD,KACE,+CAGEC,GAAwB,kBAC5B,kBAAC,GAAD,KACE,6CAGEC,GAAoB,SAAC,GAAD,IAAGvL,EAAH,EAAGA,SAAH,OACxB,yBACEiE,MAAO,CACLuH,SAAU,WACVtH,QAAS,OACTuH,IAAK,EACLC,OAAQ,EACRC,KAAM,EACNC,MAAO,EACPC,gBAAiB,UAGnB,yBAAK5H,MAAO,CAAEC,QAAS,OAAQ4H,KAAM,EAAGC,eAAgB,SAAUC,WAAY,WAC3EhM,KAKMiM,GAAiB,WAC5B,MAAkC/K,oBAAS,GAA3C,mBAAOgL,EAAP,KAAkBzB,EAAlB,KAEApK,qBAAU,WACRnE,EAAUiP,WAAW,IAAIX,GAAWC,MACnC,IAEHpK,qBAAU,WAERhF,QAAQ0L,IAAI,iBAAkBmF,KAC7B,CAACA,IASJ,OAAKA,EAGH,kBAAC,EAAD,CACEjM,QAASiK,GACTtO,OAAQ,CAAEE,QAAS,gBAAiBD,OAAQ,KAC5CqE,cAbkB,SAACiM,EAAwB5C,GAAzB,OACpBjG,YAAW,WACT8I,MAAMD,GAEN5C,GAASlO,QAAQ0L,IAAIwC,OAUrB1K,QAAS0L,IAET,kBAAC,EAAD,CACE7J,iBAAkB,OAClBC,kBAAmB0K,GACnBzK,gBAAiB0K,IAEjB,kBAAC,EAAD,QAdiB,sCC/CzBe,IAASzE,OACP,kBAAC,IAAD,KACE,kBAAC,GAAD,OAEF0E,SAASC,eAAe,S7ByHpB,kBAAmBC,WACrBA,UAAUC,cAAcC,MACrBtS,MAAK,SAACuS,GACLA,EAAaC,gBAEd9F,OAAM,SAACyC,GACNlO,QAAQkO,MAAMA,EAAMsD,c","file":"static/js/main.1aa51043.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/udilia-logo.a02392f5.svg\";","/* eslint-disable no-console */\n// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(/^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/)\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config): void {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config): void {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then((registration) => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch((error) => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config): void {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then((response) => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then((registration) => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log('No internet connection found. App is running in offline mode.');\n    });\n}\n\nexport function unregister(): void {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then((registration) => {\n        registration.unregister();\n      })\n      .catch((error) => {\n        console.error(error.message);\n      });\n  }\n}\n","// A type of promise-like that resolves synchronously and supports only one observer\nexport const _Pact = /*#__PURE__*/(function() {\n\tfunction _Pact() {}\n\t_Pact.prototype.then = function(onFulfilled, onRejected) {\n\t\tconst result = new _Pact();\n\t\tconst state = this.s;\n\t\tif (state) {\n\t\t\tconst callback = state & 1 ? onFulfilled : onRejected;\n\t\t\tif (callback) {\n\t\t\t\ttry {\n\t\t\t\t\t_settle(result, 1, callback(this.v));\n\t\t\t\t} catch (e) {\n\t\t\t\t\t_settle(result, 2, e);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t\tthis.o = function(_this) {\n\t\t\ttry {\n\t\t\t\tconst value = _this.v;\n\t\t\t\tif (_this.s & 1) {\n\t\t\t\t\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\n\t\t\t\t} else if (onRejected) {\n\t\t\t\t\t_settle(result, 1, onRejected(value));\n\t\t\t\t} else {\n\t\t\t\t\t_settle(result, 2, value);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(result, 2, e);\n\t\t\t}\n\t\t};\n\t\treturn result;\n\t}\n\treturn _Pact;\n})();\n\n// Settles a pact synchronously\nexport function _settle(pact, state, value) {\n\tif (!pact.s) {\n\t\tif (value instanceof _Pact) {\n\t\t\tif (value.s) {\n\t\t\t\tif (state & 1) {\n\t\t\t\t\tstate = value.s;\n\t\t\t\t}\n\t\t\t\tvalue = value.v;\n\t\t\t} else {\n\t\t\t\tvalue.o = _settle.bind(null, pact, state);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (value && value.then) {\n\t\t\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\n\t\t\treturn;\n\t\t}\n\t\tpact.s = state;\n\t\tpact.v = value;\n\t\tconst observer = pact.o;\n\t\tif (observer) {\n\t\t\tobserver(pact);\n\t\t}\n\t}\n}\n\nexport function _isSettledPact(thenable) {\n\treturn thenable instanceof _Pact && thenable.s & 1;\n}\n\n// Converts argument to a function that always returns a Promise\nexport function _async(f) {\n\treturn function() {\n\t\tfor (var args = [], i = 0; i < arguments.length; i++) {\n\t\t\targs[i] = arguments[i];\n\t\t}\n\t\ttry {\n\t\t\treturn Promise.resolve(f.apply(this, args));\n\t\t} catch(e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n}\n\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\nexport function _await(value, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(value) : value;\n\t}\n\tif (!value || !value.then) {\n\t\tvalue = Promise.resolve(value);\n\t}\n\treturn then ? value.then(then) : value;\n}\n\n// Awaits on a value that may or may not be a Promise, then ignores it\nexport function _awaitIgnored(value, direct) {\n\tif (!direct) {\n\t\treturn value && value.then ? value.then(_empty) : Promise.resolve();\n\t}\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continue(value, then) {\n\treturn value && value.then ? value.then(then) : then(value);\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continueIgnored(value) {\n\tif (value && value.then) {\n\t\treturn value.then(_empty);\n\t}\n}\n\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\nexport function _forTo(array, body, check) {\n\tvar i = -1, pact, reject;\n\tfunction _cycle(result) {\n\t\ttry {\n\t\t\twhile (++i < array.length && (!check || !check())) {\n\t\t\t\tresult = body(i);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pact) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t} else {\n\t\t\t\tpact = result;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t}\n\t}\n\t_cycle();\n\treturn pact;\n}\n\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forIn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tkeys.push(key);\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forOwn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tif (Object.prototype.hasOwnProperty.call(target, key)) {\n\t\t\tkeys.push(key);\n\t\t}\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\nexport const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.iterator || (Symbol.iterator = Symbol(\"Symbol.iterator\"))) : \"@@iterator\";\n\n// Asynchronously iterate through an object's values\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\nexport function _forOf(target, body, check) {\n\tif (typeof target[_iteratorSymbol] === \"function\") {\n\t\tvar iterator = target[_iteratorSymbol](), step, pact, reject;\n\t\tfunction _cycle(result) {\n\t\t\ttry {\n\t\t\t\twhile (!(step = iterator.next()).done && (!check || !check())) {\n\t\t\t\t\tresult = body(step.value);\n\t\t\t\t\tif (result && result.then) {\n\t\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (pact) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t} else {\n\t\t\t\t\tpact = result;\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t\t}\n\t\t}\n\t\t_cycle();\n\t\tif (iterator.return) {\n\t\t\tvar _fixup = function(value) {\n\t\t\t\ttry {\n\t\t\t\t\tif (!step.done) {\n\t\t\t\t\t\titerator.return();\n\t\t\t\t\t}\n\t\t\t\t} catch(e) {\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\tif (pact && pact.then) {\n\t\t\t\treturn pact.then(_fixup, function(e) {\n\t\t\t\t\tthrow _fixup(e);\n\t\t\t\t});\n\t\t\t}\n\t\t\t_fixup();\n\t\t}\n\t\treturn pact;\n\t}\n\t// No support for Symbol.iterator\n\tif (!(\"length\" in target)) {\n\t\tthrow new TypeError(\"Object is not iterable\");\n\t}\n\t// Handle live collections properly\n\tvar values = [];\n\tfor (var i = 0; i < target.length; i++) {\n\t\tvalues.push(target[i]);\n\t}\n\treturn _forTo(values, function(i) { return body(values[i]); }, check);\n}\n\nexport const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\"))) : \"@@asyncIterator\";\n\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\nexport function _forAwaitOf(target, body, check) {\n\tif (typeof target[_asyncIteratorSymbol] === \"function\") {\n\t\tvar pact = new _Pact();\n\t\tvar iterator = target[_asyncIteratorSymbol]();\n\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\treturn pact;\n\t\tfunction _resumeAfterBody(result) {\n\t\t\tif (check && check()) {\n\t\t\t\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\n\t\t\t}\n\t\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\t}\n\t\tfunction _resumeAfterNext(step) {\n\t\t\tif (step.done) {\n\t\t\t\t_settle(pact, 1);\n\t\t\t} else {\n\t\t\t\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\n\t\t\t}\n\t\t}\n\t\tfunction _reject(error) {\n\t\t\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\n\t\t}\n\t}\n\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\n}\n\n// Asynchronously implement a generic for loop\nexport function _for(test, update, body) {\n\tvar stage;\n\tfor (;;) {\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t\tif (shouldContinue.then) {\n\t\t\tstage = 0;\n\t\t\tbreak;\n\t\t}\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.s;\n\t\t\t} else {\n\t\t\t\tstage = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (update) {\n\t\t\tvar updateValue = update();\n\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\tstage = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvar pact = new _Pact();\n\tvar reject = _settle.bind(null, pact, 2);\n\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tdo {\n\t\t\tif (update) {\n\t\t\t\tupdateValue = update();\n\t\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\t\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tshouldContinue = test();\n\t\t\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t}\n\t\t} while (!result || !result.then);\n\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterBody(result);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n\tfunction _resumeAfterUpdate() {\n\t\tif (shouldContinue = test()) {\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterTest(shouldContinue);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a do ... while loop\nexport function _do(body, test) {\n\tvar awaitBody;\n\tdo {\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t} else {\n\t\t\t\tawaitBody = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t} while (!shouldContinue.then);\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tfor (;;) {\n\t\t\tshouldContinue = test();\n\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t}\n\t\t\tif (!shouldContinue) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\tresult = result.v;\n\t\t\t\t} else {\n\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tdo {\n\t\t\t\tresult = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tshouldContinue = test();\n\t\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t\t}\n\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} while (!shouldContinue.then);\n\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a switch statement\nexport function _switch(discriminant, cases) {\n\tvar dispatchIndex = -1;\n\tvar awaitBody;\n\touter: {\n\t\tfor (var i = 0; i < cases.length; i++) {\n\t\t\tvar test = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvar testValue = test();\n\t\t\t\tif (testValue && testValue.then) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tif (testValue === discriminant) {\n\t\t\t\t\tdispatchIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Found the default case, set it as the pending dispatch case\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tif (dispatchIndex !== -1) {\n\t\t\tdo {\n\t\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\t\twhile (!body) {\n\t\t\t\t\tdispatchIndex++;\n\t\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t\t}\n\t\t\t\tvar result = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tawaitBody = true;\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\t\tdispatchIndex++;\n\t\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t\treturn result;\n\t\t}\n\t}\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterTest(value) {\n\t\tfor (;;) {\n\t\t\tif (value === discriminant) {\n\t\t\t\tdispatchIndex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (++i === cases.length) {\n\t\t\t\tif (dispatchIndex !== -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttest = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvalue = test();\n\t\t\t\tif (value && value.then) {\n\t\t\t\t\tvalue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tdo {\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tvar result = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tdispatchIndex++;\n\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterBody(result) {\n\t\tfor (;;) {\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tif (!fallthroughCheck || fallthroughCheck()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdispatchIndex++;\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _call(body, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(body()) : body();\n\t}\n\ttry {\n\t\tvar result = Promise.resolve(body());\n\t\treturn then ? result.then(then) : result;\n\t} catch (e) {\n\t\treturn Promise.reject(e);\n\t}\n}\n\n// Asynchronously call a function and swallow the result\nexport function _callIgnored(body, direct) {\n\treturn _call(body, _empty, direct);\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _invoke(body, then) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(then);\n\t}\n\treturn then(result);\n}\n\n// Asynchronously call a function and swallow the result\nexport function _invokeIgnored(body) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(_empty);\n\t}\n}\n\n// Asynchronously call a function and send errors to recovery continuation\nexport function _catch(body, recover) {\n\ttry {\n\t\tvar result = body();\n\t} catch(e) {\n\t\treturn recover(e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(void 0, recover);\n\t}\n\treturn result;\n}\n\n// Asynchronously await a promise and pass the result to a finally continuation\nexport function _finallyRethrows(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer(true, e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\n\t}\n\treturn finalizer(false, result);\n}\n\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\nexport function _finally(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer();\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer, finalizer);\n\t}\n\treturn finalizer();\n}\n\n// Rethrow or return a value from a finally continuation\nexport function _rethrow(thrown, value) {\n\tif (thrown)\n\t\tthrow value;\n\treturn value;\n}\n\n// Empty function to implement break and other control flow that ignores asynchronous results\nexport function _empty() {\n}\n\n// Sentinel value for early returns in generators \nexport const _earlyReturn = /*#__PURE__*/ {};\n\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\nexport function _catchInGenerator(body, recover) {\n\treturn _catch(body, function(e) {\n\t\tif (e === _earlyReturn) {\n\t\t\tthrow e;\n\t\t}\n\t\treturn recover(e);\n\t});\n}\n\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\nexport const _AsyncGenerator = /*#__PURE__*/(function() {\n\tfunction _AsyncGenerator(entry) {\n\t\tthis._entry = entry;\n\t\tthis._pact = null;\n\t\tthis._resolve = null;\n\t\tthis._return = null;\n\t\tthis._promise = null;\n\t}\n\n\tfunction _wrapReturnedValue(value) {\n\t\treturn { value: value, done: true };\n\t}\n\tfunction _wrapYieldedValue(value) {\n\t\treturn { value: value, done: false };\n\t}\n\n\t_AsyncGenerator.prototype._yield = function(value) {\n\t\t// Yield the value to the pending next call\n\t\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\n\t\t// Return a pact for an upcoming next/return/throw call\n\t\treturn this._pact = new _Pact();\n\t};\n\t_AsyncGenerator.prototype.next = function(value) {\n\t\t// Advance the generator, starting it if it has yet to be started\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tconst _entry = _this._entry;\n\t\t\t\tif (_entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the next call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Start the generator\n\t\t\t\t_this._entry = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\tfunction returnValue(value) {\n\t\t\t\t\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t_this._resolve = null;\n\t\t\t\t}\n\t\t\t\tvar result = _entry(_this);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tresult.then(returnValue, function(error) {\n\t\t\t\t\t\tif (error === _earlyReturn) {\n\t\t\t\t\t\t\treturnValue(_this._return);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst pact = new _Pact();\n\t\t\t\t\t\t\t_this._resolve(pact);\n\t\t\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t\t\t_this._resolve = null;\n\t\t\t\t\t\t\t_resolve(pact, 2, error);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treturnValue(result);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Generator is started and a yield expression is pending, settle it\n\t\t\t\t_this._pact = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\t_settle(_pact, 1, value);\n\t\t\t}\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.return = function(value) {\n\t\t// Early return from the generator if started, otherwise abandons the generator\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the return call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return the specified value\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t}\n\t\t\t// Settle the yield expression with a rejected \"early return\" value\n\t\t\t_this._return = value;\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, _earlyReturn);\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.throw = function(error) {\n\t\t// Inject an exception into the pending yield expression\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve, reject) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the throw call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return a rejected Promise containing the error\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn reject(error);\n\t\t\t}\n\t\t\t// Settle the yield expression with the value as a rejection\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, error);\n\t\t});\n\t};\n\n\t_AsyncGenerator.prototype[_asyncIteratorSymbol] = function() {\n\t\treturn this;\n\t};\n\t\n\treturn _AsyncGenerator;\n})();\n","/* eslint-disable no-console */\nimport { createContext } from 'react';\n\nimport { RBAuthTokensType } from '../types';\n\nimport { RBAuthContextType, RBAuthReactContext, RBAuthUserModelWithRole, RBAuthBaseRoles } from '../types';\n\nexport const RBAuthInitialUser: RBAuthUserModelWithRole<RBAuthBaseRoles> = {\n  role: 'public',\n};\nexport const RBAuthInitialToken: RBAuthTokensType = {\n  accessToken: '',\n  refreshToken: '',\n  openIdToken: '',\n  tokenType: '',\n  expiresIn: '',\n  scope: '',\n};\n\nexport const AuthContext = createContext<RBAuthContextType>({\n  // to check if authenticated or not\n  isAuth: false,\n  reloading: true,\n  // store user\n  user: RBAuthInitialUser,\n  // accessToken of user for Auth0\n  logic: {\n    // login process\n    login: async () => console.log('please change login'),\n    // signup process\n    signup: async () => console.log('please change signup'),\n    // logout the user\n    logout: async () => console.log('please change logout'),\n    silent: async () => console.log('please change silent'),\n    // handle Auth0 login process\n    handle: async () => console.log('please change handle'),\n    refresh: async () => console.log('please change refresh'),\n    apis: {},\n  },\n  routes: {\n    public: '/',\n    private: '/dashboard',\n  },\n  rules: {\n    // visitor permissions\n    public: {\n      static: ['home-page:visit'],\n    },\n    // admin permissions\n    admin: {\n      static: ['home-page:visit', 'dashboard-page:visit'],\n    },\n  },\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n}) as RBAuthReactContext<any, any, any, any, any, any, any, any, any>;\n","import React from 'react';\n\n/**\n * RefreshToken Errors\n */\nenum RBAuthErrors {\n  INVALID_GRANT = 'invalid_grant',\n  REFRESH_TOKEN_REVOKED = 'refreshTokenRevoked',\n  REFRESH_TOKEN_NOT_PRESENT = 'noRefreshToken',\n  UNAUTHORIZED = 'Unauthorized',\n  TOO_MANY_REQUESTS = 'Too Many Requests',\n  FAILLED_TO_FETCH = 'failled to fetch',\n  UNKNOWN = 'UNKNOWN',\n}\n\n/**\n * SecureRoute Types\n */\nexport type RBAuthRedirect = React.FC<{ to: string }>;\n\n/**\n * Roles Types\n */\nexport type RBAuthBaseRoles = 'admin' | 'public';\n\n/**\n * Rule Types\n */\ntype RBAuthStaticRulesType = string[];\ntype RBAuthDynamicRulesType = {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  [key: string]: (...args: any) => boolean;\n};\nexport type RBAuthRulesInterface<RoleType extends string> = {\n  [key in RoleType]: {\n    static?: RBAuthStaticRulesType;\n    dynamic?: RBAuthDynamicRulesType;\n  };\n};\n\n/**\n * User types\n */\ntype RBAuthGenericRoles<T extends string> = 'admin' | 'public' | T;\nexport interface RBAuthUserModelWithRole<T extends string = RBAuthBaseRoles> {\n  role: RBAuthGenericRoles<T>;\n}\n\n/**\n * Context types\n */\nexport type KnownAuthProcess<R> = (...args: any) => Promise<R>;\nexport type UnknownAuthProcess = <R>(...args: any) => Promise<R | unknown | void>;\nexport type UnknownRefreshProcess = <R>(reloadFlag?: boolean) => Promise<R | unknown | void>;\n\n// Auth Context type\nexport type RBAuthContextType<\n  TUser extends RBAuthUserModelWithRole<string> = RBAuthUserModelWithRole,\n  TRules extends RBAuthRulesInterface<string> = RBAuthRulesInterface<RBAuthBaseRoles>,\n  LoginType = UnknownAuthProcess,\n  LogOutType = UnknownAuthProcess,\n  SignUpType = UnknownAuthProcess,\n  SilentAuthType = UnknownAuthProcess,\n  HandleAuthType = UnknownAuthProcess,\n  RefreshTokens = UnknownRefreshProcess,\n  TApis = Record<string, unknown>\n> = {\n  isAuth: boolean; // to check if authenticated or not\n  reloading: boolean;\n  user: TUser; // store all the user details\n  logic: {\n    login: LoginType; // to start the login process\n    signup: SignUpType;\n    silent: SilentAuthType;\n    handle: HandleAuthType; // handle Auth0 login process\n    logout: LogOutType; // logout the user\n    refresh: RefreshTokens;\n    apis: TApis;\n  };\n  routes: {\n    public: string;\n    private: string;\n  };\n  rules?: TRules;\n};\n\n/**\n * React Context Type - for your AppAuthContext\n */\nexport type RBAuthReactContext<\n  TUser extends RBAuthUserModelWithRole<string>,\n  TRules extends RBAuthRulesInterface<string>,\n  LoginType extends UnknownAuthProcess = UnknownAuthProcess,\n  LogOutType extends UnknownAuthProcess = UnknownAuthProcess,\n  SignUpType extends UnknownAuthProcess = UnknownAuthProcess,\n  HandleAuthType extends UnknownAuthProcess = UnknownAuthProcess,\n  SilentAuthType extends UnknownAuthProcess = UnknownAuthProcess,\n  RefreshTokensType extends UnknownAuthProcess = UnknownAuthProcess,\n  // AppApis\n  TApi extends Record<string, unknown> = Record<string, unknown>\n> = React.Context<\n  RBAuthContextType<\n    TUser,\n    TRules,\n    LoginType,\n    LogOutType,\n    SignUpType,\n    SilentAuthType,\n    HandleAuthType,\n    RefreshTokensType,\n    // AppApis\n    TApi\n  >\n>;\n\n/**\n * Types for Auth processing\n */\nexport type SetterType = (variable: any) => void;\n\nexport interface AuthApiInterface {\n  login: KnownAuthProcess<{\n    tokens: RBAuthTokensType;\n    user: RBAuthUserModelWithRole<RBAuthBaseRoles>;\n  }>;\n  logout: UnknownAuthProcess;\n  signup: UnknownAuthProcess;\n  handle: KnownAuthProcess<{\n    tokens: RBAuthTokensType;\n    user: RBAuthUserModelWithRole<RBAuthBaseRoles>;\n  }>;\n  silent: KnownAuthProcess<{\n    tokens: RBAuthTokensType;\n    user: RBAuthUserModelWithRole<RBAuthBaseRoles>;\n  }>;\n}\nexport type PartialAuthApi = Partial<AuthApiInterface>;\n\nexport type RBAuthTokensType = {\n  accessToken: string;\n  refreshToken: string;\n  openIdToken: string;\n  expiresIn: string;\n  scope: string;\n  tokenType: string;\n};\n\n/**\n * RBAuthStorageType\n * @implNote\n * If you create any 'get Tokens' functionality, please make it private, either by using ES6 classes or\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures#Emulating_private_methods_with_closures\n */\nexport type RBAuthStorageType = {\n  accessToken: string;\n  refreshToken: string;\n  openIdToken: string;\n  tokenType: string;\n  expiresIn: string;\n  scope: string;\n  setTokens: (tokens: RBAuthTokensType) => void;\n};\n\nexport {\n  //\n  RBAuthErrors,\n};\n","import { RBAuthTokensType, RBAuthStorageType } from '../types';\n\nimport { RBAuthInitialToken } from '../roles-based-auth/context';\n\nconst initialStorage: RBAuthStorageType = {\n  accessToken: '',\n  refreshToken: '',\n  openIdToken: '',\n  tokenType: '',\n  expiresIn: '',\n  scope: '',\n  setTokens: () => null,\n};\n\nexport class TokenUtil {\n  private static s: RBAuthStorageType = initialStorage;\n\n  static setStorage(storage: RBAuthStorageType) {\n    TokenUtil.s = storage;\n  }\n\n  static setTokens = (t: RBAuthTokensType = RBAuthInitialToken) => TokenUtil.s.setTokens(t);\n\n  static getTokens(): RBAuthTokensType {\n    return {\n      accessToken: TokenUtil.s.accessToken || '',\n      refreshToken: TokenUtil.s.refreshToken || '',\n      openIdToken: TokenUtil.s.openIdToken || '',\n      tokenType: TokenUtil.s.tokenType || '',\n      expiresIn: TokenUtil.s.expiresIn || '',\n      scope: TokenUtil.s.scope || '',\n    };\n  }\n}\n","import { RBAuthErrors } from '../types';\n\nconst RECUR_LEVEL = 1;\n\ntype RefreshType = (reloadFlag?: boolean) => Promise<Response>;\ntype RequestType = <T>() => Promise<T>;\n\ntype OnSuccessType = <T>(arg: T) => void;\ntype OnFailureType = (error: RBAuthErrors) => void;\n\nclass RequestWrapper {\n  private static recursion = async (\n    refresh: RefreshType,\n    req: RequestType,\n    onSuccess: OnSuccessType,\n    onFailure: OnFailureType,\n    recursion = RECUR_LEVEL,\n    accessTokenError = RBAuthErrors.UNAUTHORIZED,\n    refresTokenError = RBAuthErrors.INVALID_GRANT\n  ): Promise<void> => {\n    // console.log('RequestWrapper::recursion');\n    try {\n      // console.log('RequestWrapper::recursion will request');\n      await req();\n      // console.log('RequestWrapper::recursion has request');\n    } catch (e) {\n      if (e.message === accessTokenError && recursion >= 1) {\n        try {\n          // refresh\n          await refresh();\n          // then\n          return RequestWrapper.recursion(refresh, req, onSuccess, onFailure, recursion - 1, accessTokenError, refresTokenError);\n        } catch (error) {\n          onFailure(RBAuthErrors.REFRESH_TOKEN_REVOKED);\n          throw new Error(RBAuthErrors.REFRESH_TOKEN_REVOKED);\n        }\n      } else {\n        onFailure(e);\n      }\n      throw e;\n    }\n  };\n\n  /**\n   * RequestWrapper::handle()\n   *\n   * @param request Actual request to be performed\n   * @param onSuccess Receives res: <T>(res: T) => void as success logic\n   * @param onFailure Receives error: <T>(error: T) => void as failure logic\n   */\n  static handle(\n    request: RequestType,\n    onSuccess: OnSuccessType,\n    onFailure: OnFailureType,\n    recursion = RECUR_LEVEL,\n    accessTokenError = RBAuthErrors.UNAUTHORIZED,\n    refresTokenError = RBAuthErrors.INVALID_GRANT\n  ) {\n    /**\n     * onPress logic\n     * @param refresh Logic for refreshing tokens\n     */\n    return (refreshLogic: RefreshType) => async () =>\n      RequestWrapper.recursion(refreshLogic, request, onSuccess, onFailure, recursion, accessTokenError, refresTokenError);\n  }\n}\n\nexport class ApiAccessBuilder {\n  private success: OnSuccessType = () => null;\n  private failure: OnFailureType = () => null;\n  private recursions: number = RECUR_LEVEL;\n  private accessTokenError: RBAuthErrors = RBAuthErrors.INVALID_GRANT;\n  private refreshTokenError: RBAuthErrors = RBAuthErrors.REFRESH_TOKEN_REVOKED;\n\n  constructor(private logic: <T>() => Promise<T>) {}\n\n  withAccessTokenError(accessTokenError: RBAuthErrors) {\n    this.accessTokenError = accessTokenError;\n    return this;\n  }\n\n  withRefreshTokenError(refreshTokenError: RBAuthErrors) {\n    this.refreshTokenError = refreshTokenError;\n    return this;\n  }\n\n  withSuccess(success: OnSuccessType) {\n    this.success = success;\n    return this;\n  }\n\n  withFailure(failure: OnFailureType) {\n    this.failure = failure;\n    return this;\n  }\n\n  withCustomRecursions(recursions: number) {\n    this.recursions = recursions;\n    return this;\n  }\n\n  build(refresh: RefreshType) {\n    return RequestWrapper.handle(\n      this.logic,\n      this.success,\n      this.failure,\n      this.recursions,\n      this.accessTokenError,\n      this.refreshTokenError\n    )(refresh);\n  }\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { TokenUtil } from './TokenUtilities';\nimport { ApiAccessBuilder } from './RequestWrapper';\n\nimport {\n  UnknownAuthProcess,\n  SetterType,\n  AuthApiInterface,\n  RBAuthTokensType,\n  RBAuthUserModelWithRole,\n  KnownAuthProcess,\n  RBAuthErrors,\n  RBAuthBaseRoles,\n} from '../types';\nimport { RBAuthInitialToken } from '../roles-based-auth/context';\n\ntype AuthProcessResponse = KnownAuthProcess<{\n  tokens: RBAuthTokensType;\n  user: RBAuthUserModelWithRole<RBAuthBaseRoles>;\n}>;\n\ntype RefreshProcessResponse = KnownAuthProcess<RBAuthTokensType>;\n\ntype ProcessesType<\n  TLoging,\n  LogOutType,\n  SignUpType,\n  SilentAuthType,\n  HandleAuthType,\n  RefreshTokens\n> = {\n  login?: TLoging;\n  logout?: LogOutType;\n  signup?: SignUpType;\n  silent?: SilentAuthType;\n  handle?: HandleAuthType;\n  refresh?: RefreshTokens;\n};\n\nabstract class UserReloader {\n  constructor(public setReloading: SetterType, public setUser: SetterType) {}\n}\n\ntype RefreshTokenEndLifeCallbackType = (rbAuthErros: RBAuthErrors, error?: Error) => void;\n\nconst dummyFunction = (arg: unknown) => new Promise<unknown>((r) => r(arg));\n\nexport class BaseAuthApiWrapper<\n    LoginType extends KnownAuthProcess<{\n      tokens: RBAuthTokensType;\n      user: RBAuthUserModelWithRole<RBAuthBaseRoles>;\n    }>,\n    LogOutType extends UnknownAuthProcess,\n    SignUpType extends KnownAuthProcess<unknown>,\n    SilentType extends KnownAuthProcess<{\n      tokens: RBAuthTokensType;\n      user: RBAuthUserModelWithRole<RBAuthBaseRoles>;\n    }>,\n    HandleType extends KnownAuthProcess<{\n      tokens: RBAuthTokensType;\n      user: RBAuthUserModelWithRole<RBAuthBaseRoles>;\n    }>,\n    RefreshType extends KnownAuthProcess<RBAuthTokensType>,\n    AppApis extends Record<string, unknown>\n  >\n  extends UserReloader\n  implements AuthApiInterface {\n  defaultLogin: LoginType = dummyFunction as LoginType;\n  defaultLogout: LogOutType = dummyFunction as LogOutType;\n  defaultSignupLogic: SignUpType = dummyFunction as SignUpType;\n  defaultSilentLogic: SilentType = dummyFunction as SilentType;\n  defaultHandleLogic: HandleType = dummyFunction as HandleType;\n  defaultRefreshLogic: RefreshType = dummyFunction as RefreshType;\n\n  private loginLogic: LoginType = this.defaultLogin;\n  private logoutLogic: LogOutType = this.defaultLogout;\n  private signupLogic: SignUpType = this.defaultSignupLogic;\n  private silentLogic: SilentType = this.defaultSilentLogic;\n  private handleLogic: HandleType = this.defaultHandleLogic;\n  private refreshLogic: RefreshType = this.defaultRefreshLogic;\n  private errorCallback: RefreshTokenEndLifeCallbackType = () => null;\n  private appApis: Record<string, unknown> = {};\n\n  constructor(\n    setReloading: SetterType,\n    setUser: SetterType,\n    processes: ProcessesType<\n      LoginType,\n      LogOutType,\n      SignUpType,\n      SilentType,\n      HandleType,\n      RefreshType\n    >,\n    refreshTokenEndLifeCallback?: RefreshTokenEndLifeCallbackType,\n    appApis?: AppApis\n  ) {\n    super(setReloading, setUser);\n    if (refreshTokenEndLifeCallback) this.errorCallback = refreshTokenEndLifeCallback;\n    if (appApis) this.appApis = this.embedWrapperLogicIntoApis(appApis);\n    if (!processes) return;\n    if (processes.login) this.loginLogic = processes.login;\n    if (processes.logout) this.logoutLogic = processes.logout;\n    if (processes.signup) this.signupLogic = processes.signup;\n    if (processes.handle) this.handleLogic = processes.handle;\n    if (processes.silent) this.silentLogic = processes.silent;\n    if (processes.refresh) this.refreshLogic = processes.refresh;\n  }\n\n  public get apis(): Record<string, unknown> {\n    return this.appApis;\n  }\n\n  login: AuthProcessResponse = async (...args: any) => this.runLogic(this.loginLogic)(...args);\n  handle: AuthProcessResponse = async (...args: any) => this.runLogic(this.handleLogic)(...args);\n  silent: AuthProcessResponse = async (...args: any) => this.runLogic(this.silentLogic)(...args);\n  // simple signup\n  signup: UnknownAuthProcess = (...args: any) => this.signupLogic(...args);\n  // custom logic\n  refresh: RefreshProcessResponse = async (f: boolean) => this.runRefresh(this.refreshLogic)(f);\n  logout: UnknownAuthProcess = async (...args: any) =>\n    this.wrap(async () => {\n      const res = await this.logoutLogic(...args);\n      await this.authenticate();\n      return res;\n    });\n\n  /**\n   * private Helpers\n   */\n  private embedWrapperLogicIntoApis(apis: AppApis) {\n    const result: Record<string, unknown> = {};\n    Object.keys(apis).forEach((item) => {\n      if (item.startsWith('logic') && apis[item] && typeof apis[item] === 'function')\n        result[item] = this.apiWrap(apis[item] as <T>() => Promise<T>);\n      else if (apis[item] !== null && typeof apis[item] === 'object')\n        result[item] = this.embedWrapperLogicIntoApis(apis[item] as AppApis);\n      else result[item] = apis[item];\n    });\n    return result;\n  }\n\n  private runLogic = (logic: AuthProcessResponse) => async (\n    ...args: any\n  ): Promise<{\n    tokens: RBAuthTokensType;\n    user: RBAuthUserModelWithRole<RBAuthBaseRoles>;\n  }> =>\n    this.wrap(async () => {\n      const res = await logic(...args);\n      // console.log('res', res);\n      await this.authenticate(res);\n      return res;\n    });\n\n  private runRefresh = (logic: RefreshProcessResponse) => async (flag: boolean) =>\n    this.wrap(async () => {\n      const res = await logic();\n      if (res.refreshToken) await TokenUtil.setTokens(res);\n      return res;\n    }, flag);\n\n  // this means the access token got krazy!\n  private accessTokenError = RBAuthErrors.UNAUTHORIZED;\n  private refreshTokenError = RBAuthErrors.INVALID_GRANT;\n\n  private apiWrap = (logic: <T>() => Promise<T>) => (\n    onSuccess: <T>(arg: T) => void,\n    onError: (error: RBAuthErrors) => void\n  ) => {\n    // console.log('inside apiWrap');\n    return new ApiAccessBuilder(logic)\n      .withSuccess(onSuccess)\n      .withFailure(onError)\n      .withAccessTokenError(this.accessTokenError)\n      .withRefreshTokenError(this.refreshTokenError)\n      .build(this.refresh as any);\n  };\n\n  private wrap = async <T>(logic: () => T, flag = true) => {\n    if (flag) this.setReloading(true);\n    try {\n      return await logic();\n    } catch (e) {\n      // console.log('wrap catch: ', e.message);\n      if (e.message === 'Failed to fetch') this.errorCallback(RBAuthErrors.FAILLED_TO_FETCH, e);\n      // others\n      else if (e.message === RBAuthErrors.UNAUTHORIZED) this.errorCallback(e);\n      else if (e.message === RBAuthErrors.REFRESH_TOKEN_NOT_PRESENT) {\n        // swallow silently\n      }\n      // all others\n      else if (e.message !== RBAuthErrors.REFRESH_TOKEN_NOT_PRESENT)\n        this.errorCallback(RBAuthErrors.UNKNOWN, e);\n      throw e;\n    } finally {\n      if (flag) this.setReloading(false);\n    }\n    // try {\n    //   return logic();\n    // } catch (error) {\n    //   if (error.message === AuthErrors.REFRESH_TOKEN_NOT_PRESENT) {\n    //     // swallow\n    //   }\n    //   //  else if (error.message === AuthErrors.REFRESH_TOKEN_REVOKED) {\n    //   //   this.errorCallback(AuthErrors.REFRESH_TOKEN_REVOKED);\n    //   // } else if (\n    //   //   error.mesage === AuthErrors.UNAUTHORIZED ||\n    //   //   error.mesage === 'JSON Parse error: Unexpected identifier \"Unauthorized\"'\n    //   // ) {\n    //   //   this.errorCallback(AuthErrors.UNAUTHORIZED);\n    //   // } else if (error.message === AuthErrors.TOO_MANY_REQUESTS) {\n    //   //   this.errorCallback(AuthErrors.TOO_MANY_REQUESTS);\n    //   // }\n    //   console.log('wrap catch: ', error, error.message);\n    //   // throw error;\n    //   return null;\n    // } finally {\n    //   if (flag) this.setReloading(false);\n    // }\n  };\n\n  private authenticate = async (\n    res: {\n      tokens: RBAuthTokensType;\n      user: RBAuthUserModelWithRole<RBAuthBaseRoles>;\n    } | null = null\n  ) => {\n    if (res && res.user && res.tokens) {\n      this.setUser(res.user);\n      await TokenUtil.setTokens(res.tokens);\n    } else {\n      this.setUser(null);\n      await TokenUtil.setTokens(RBAuthInitialToken);\n    }\n  };\n}\n","import React, { useEffect } from 'react';\n\nimport { RBAuthUserModelWithRole, RBAuthBaseRoles, RBAuthContextType, PartialAuthApi, RBAuthErrors } from '../types';\nimport { BaseAuthApiWrapper } from '../authServices/BaseAuthApiWrapper';\nimport { AuthContext, RBAuthInitialUser } from '../roles-based-auth/context';\n\nexport const Auth: React.FC<{\n  authApi: PartialAuthApi;\n  routes?: { private: string; public: string };\n  onAuthExpired?: (e: RBAuthErrors) => void;\n  appApis?: Record<string, unknown>;\n  monitorUserChanges?: null | ((user: RBAuthUserModelWithRole<RBAuthBaseRoles> | null) => void);\n}> = ({ children, authApi, routes, onAuthExpired, appApis = {}, monitorUserChanges = null }) => {\n  const [reloading, setReloading] = React.useState(true);\n  const [user, setUser] = React.useState<RBAuthUserModelWithRole<RBAuthBaseRoles> | null>(null);\n\n  const logic = new BaseAuthApiWrapper(setReloading, setUser, authApi, onAuthExpired, appApis);\n\n  useEffect(() => {\n    if (monitorUserChanges) monitorUserChanges(user);\n  }, [user]);\n\n  const contextVal: RBAuthContextType = {\n    isAuth: !!(user && user.role && user.role !== 'public'),\n    reloading,\n    logic,\n    routes: { private: routes?.private || '/private', public: routes?.public || '/' },\n    user: user || RBAuthInitialUser,\n    rules: {\n      admin: {},\n      public: {},\n    },\n  };\n\n  return <AuthContext.Provider value={contextVal}>{children}</AuthContext.Provider>;\n};\n","import React, { useContext, useState, useEffect } from 'react'\n\nimport { AuthContext } from '../roles-based-auth/context'\n\nclass FirstRun {\n  public static done = false\n}\n\nexport const RefreshApp: React.FC<{\n  locationPathName: string\n  AuthReloadingComp: React.FC\n  AuthLoadingComp?: React.FC\n  authCallbackRoute?: string\n  debug?: boolean\n}> = ({\n  children,\n  locationPathName,\n  AuthReloadingComp,\n  AuthLoadingComp = undefined,\n  authCallbackRoute,\n  debug = false\n}) => {\n  const auth = useContext(AuthContext)\n  const [isReloading, setIsReloading] = useState(true)\n\n  useEffect(() => {\n    if (auth.reloading && AuthLoadingComp !== undefined) setIsReloading(true)\n    else setIsReloading(false)\n  }, [auth.reloading, AuthLoadingComp])\n\n  const silentSwallow = () => {}\n\n  useEffect(() => {\n    if (!FirstRun.done && locationPathName !== authCallbackRoute) {\n      FirstRun.done = true\n      // eslint-disable-next-line no-console\n      if (debug) {\n        console.log('will issue silent auth')\n        auth.logic.silent().then(console.log).catch(console.log)\n      } else auth.logic.silent().then(silentSwallow).catch(silentSwallow)\n    }\n  }, [])\n\n  if (!FirstRun.done && AuthReloadingComp) return <AuthReloadingComp />\n  else\n    return (\n      <React.Fragment>\n        {isReloading && AuthLoadingComp && <AuthLoadingComp />}\n        {children}\n      </React.Fragment>\n    )\n}\n","import { DEFAULT_TIMEOUT, fetchWithTimeout } from '../utils/FetchWithTimeout';\n\nexport enum HTTPMethod {\n  POST = 'POST',\n  GET = 'GET',\n  PATCH = 'PATCH',\n  PUT = 'PUT',\n  DELETE = 'DELETE',\n  HEAD = 'HEAD',\n  CONNECT = 'CONNECT',\n  TRACE = 'TRACE',\n}\n\ntype ModeType = 'no-cors';\ntype ErrorHandlerType<T> = (error: T) => void;\n\nexport class RequestBuilder {\n  private route = '';\n  private body: Record<string, unknown> | null = null;\n  private headers: Headers = new Headers();\n  private method: HTTPMethod = HTTPMethod.GET;\n  private mode: ModeType | null = null;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  private errorHandling: ErrorHandlerType<any> | null = null;\n  private timeout: number = DEFAULT_TIMEOUT;\n\n  constructor(route: string, private debug = false) {\n    this.route = route;\n    return this;\n  }\n  withAuth0Body(body: Record<string, unknown> = {}) {\n    this.body = body;\n    return this;\n  }\n  withErrorHandling<T>(callback: ErrorHandlerType<T>) {\n    this.errorHandling = callback;\n    return this;\n  }\n  withBody(body: Record<string, unknown> = {}) {\n    this.body = body;\n    return this;\n  }\n  withHeaders(headers: Headers) {\n    this.headers = headers;\n    return this;\n  }\n  withMethod(method: HTTPMethod) {\n    this.method = method;\n    return this;\n  }\n  withMode(mode: ModeType) {\n    this.mode = mode;\n    return this;\n  }\n  withTimeout(timeout: number) {\n    this.timeout = timeout;\n    return this;\n  }\n  private request() {\n    if (this.debug) {\n      const debugHeaders: Record<string, string> = {};\n      this.headers.forEach((value: string, key: string) => (debugHeaders[key] = value));\n      // eslint-disable-next-line no-console\n      console.log('will request: ', this.route, this.method, JSON.stringify(debugHeaders), JSON.stringify(this.body));\n    }\n\n    const opts: { method: HTTPMethod; headers: Headers; mode?: ModeType; body?: string } = {\n      method: this.method,\n      headers: this.headers,\n    };\n    if (this.mode) opts.mode = this.mode;\n    if (this.method !== HTTPMethod.GET && this.method !== HTTPMethod.HEAD && this.body) opts['body'] = JSON.stringify(this.body);\n    return fetchWithTimeout(this.route, opts, this.timeout);\n  }\n\n  async build<T>(): Promise<T> {\n    let result: unknown;\n    const res = await this.request();\n    const contentType = res.headers.get('content-type');\n    const success = res.ok;\n    if (contentType && contentType.indexOf('application/json') !== -1) result = await res.json();\n    else result = (await res.text()) as unknown;\n    if (!success) {\n      if (this.errorHandling) this.errorHandling(result);\n      throw Error(result as string);\n    }\n    return result as T;\n  }\n}\n","import React from 'react';\n\nimport { RBAuthRedirect } from '../types';\nimport { AuthContext } from '../roles-based-auth/context';\n\nexport const SecureScreen: React.FC<{\n  Redirect: RBAuthRedirect;\n  Allowed: React.FC;\n  NotAllowed?: React.FC;\n}> = ({ Redirect, Allowed, NotAllowed }) => (\n  <AuthContext.Consumer>\n    {(auth) => {\n      if (!auth.isAuth) {\n        if (NotAllowed) return <NotAllowed />;\n        // TODO: set 'last route' in auth context if app needs to gracefully recover\n        return <Redirect to={auth.routes?.public || '/'} />;\n      }\n      return <Allowed />;\n    }}\n  </AuthContext.Consumer>\n);\n","import { TokenUtil } from './TokenUtilities';\n\nexport class HeadersBuilder {\n  headers = new Headers();\n  constructor() {\n    return this;\n  }\n\n  withKeyValuePair(key: string, value: string) {\n    this.headers.append(key, value);\n    return this;\n  }\n\n  withContentTypeJson() {\n    this.headers.append('Content-Type', 'application/json');\n    return this;\n  }\n\n  withToken(type: string | 'Bearer', token: string) {\n    this.headers.append('Authorization', `${type} ${token}`);\n    return this;\n  }\n\n  withRBAuthToken() {\n    this.headers.append('Authorization', `${TokenUtil.getTokens().tokenType} ${TokenUtil.getTokens().accessToken}`);\n    return this;\n  }\n\n  build() {\n    return this.headers;\n  }\n}\n","export const DEFAULT_TIMEOUT = 7000;\n\nexport const fetchWithTimeout = (requestInfo: RequestInfo, requestInit?: RequestInit, timeout = DEFAULT_TIMEOUT) =>\n  Promise.race<Promise<Response>>([\n    fetch(requestInfo, requestInit),\n    new Promise((_, reject) => setTimeout(() => reject(new Error('timeout')), timeout)),\n  ]);\n","import React from 'react';\nimport udiliaLogo from './udilia-logo.svg';\nimport './Example.css';\n\nexport const Example: React.FC = (props) => (\n  <div className=\"Example\">\n    {props.children}\n    <img src={udiliaLogo} alt=\"React logo\" width=\"62\" />\n    <h1 className=\"Example-text\">React Role Based Auth Library</h1>\n  </div>\n);\n","import React from 'react';\nimport './SecondExample.css';\n\nconst Table: React.FC = ({ children }) => <div style={{ display: 'flex' }}>{children}</div>;\n\nexport const SecondExample: React.FC = (props) => (\n  <div className=\"SecondExample\">\n    <div className=\"SecondExample-text\">\n      <Table></Table>\n    </div>\n    <a\n      className=\"SecondExample-github-link\"\n      target=\"_blank\"\n      rel=\"noopener noreferrer\"\n      href=\"https://github.com/nmpribeiro/react-role-based-auth/blob/master/README.md\"\n    >\n      Documentation\n    </a>\n    {props.children}\n  </div>\n);\n","import { AuthContext, RBAuthReactContext } from 'react-rb-auth'\n\nimport {\n  LoginType,\n  SignupType,\n  HandleType,\n  SilentType,\n  LogoutType,\n  RefreshType\n} from './AuthApi'\nimport { GlobalAppApi } from './ExternalApi'\nimport { UserModel } from '../models/user'\nimport { rules } from '../models/rules'\n\ntype GlobalApi = typeof GlobalAppApi\n\nexport const AppAuthContext = AuthContext as RBAuthReactContext<\n  UserModel,\n  typeof rules,\n  LoginType,\n  LogoutType,\n  SignupType,\n  HandleType,\n  SilentType,\n  RefreshType,\n  GlobalApi\n>\n","import React, { useState, useContext } from 'react'\n\nimport { AppAuthContext } from '../services/AppAuthContext'\n\nexport const Login: React.FC = () => {\n  const { logic } = useContext(AppAuthContext)\n  const [email, setEmail] = useState('')\n  const [password, setPassword] = useState('')\n\n  const onChangeEvent =\n    (\n      setter: (val: string) => void\n    ): React.ChangeEventHandler<HTMLInputElement> =>\n    (val) =>\n      setter(val.target.value)\n\n  const submit = () => logic.login(email, password)\n\n  return (\n    <div>\n      <h3>You are anonymous</h3>\n      <h3>Please login</h3>\n      <input value={email} type='text' onChange={onChangeEvent(setEmail)} />\n      <input\n        value={password}\n        type='password'\n        onChange={onChangeEvent(setPassword)}\n      />\n      <button onClick={submit}>Login</button>\n    </div>\n  )\n}\n","function get2Chars(str = '') {\n  return str.slice(0, 2).toUpperCase();\n}\n\nfunction twoDigits(str: string) {\n  return `${str.length < 2 ? '0' : ''}${str}`;\n}\n\nconst formatDate = (date: Date | null) => {\n  if (date === null) return '';\n  const month = (date.getMonth() + 1).toString();\n  const day = date.getDate().toString();\n  const hour = (date.getHours() + 1).toString();\n  const minutes = (date.getMinutes() + 1).toString();\n  const seconds = (date.getSeconds() + 1).toString();\n\n  const year = date.getFullYear();\n\n  const dateTime = [year, twoDigits(month), twoDigits(day)].join('-');\n  const clockTime = `${twoDigits(hour)}:${twoDigits(minutes)}:${twoDigits(seconds)}`;\n  return `${dateTime} ${clockTime}`;\n};\n\nexport const Utils = {\n  get2Chars,\n  formatDate,\n};\n","/* eslint-disable no-console */\nimport React, { useContext, useState } from 'react';\nimport { AppAuthContext } from '../services/AppAuthContext';\nimport { Utils } from '../services/Utils';\n\ntype RetrievedUserType = {\n  nickname: string;\n  date: Date;\n  lastFetched: Date |null;\n};\n\nexport const Logout: React.FC = () => {\n  const auth = useContext(AppAuthContext);\n  const logout = () =>\n    auth.logic\n      .logout()\n      .then(() => null)\n      .catch(() => null);\n\n  const [retrievedUser, setRetrievedUser] = useState<RetrievedUserType|null>(null);\n\n  const getUser = () => {\n    auth.logic.apis.external\n      .getUser()\n      .then((res) =>\n        setRetrievedUser({\n          nickname: ((res as unknown) as RetrievedUserType).nickname,\n          date: new Date(),\n          lastFetched: retrievedUser?.date || null,\n        })\n      )\n      .catch(console.log);\n  };\n  const refresh = () => auth.logic.refresh().then(console.log).catch(console.log);\n  return (\n    <div>\n      <h3>Welcome USER!</h3>\n      <h5>Your name is: {auth.user.name}</h5>\n      <img\n        style={{ maxHeight: 100, borderRadius: 50 }}\n        src={auth.user.picture}\n        alt={auth.user.name}\n      />\n      <h5>Your slug is: {auth.user.nickname}</h5>\n      <button onClick={logout}>Logout</button>\n      <div>\n        <button onClick={refresh}>Refresh tokens</button>\n        <button onClick={getUser}>Get user</button>\n        {retrievedUser && (\n          <div>\n            <h3>Got user: </h3>\n            <h5>{retrievedUser.nickname}</h5>\n            <p>\n              Last retrieved:\n              {`\\u0009${Utils.formatDate(retrievedUser.lastFetched)}`}\n            </p>\n            <p>\n              Retrieved:\n              {`\\u0009\\u0009${Utils.formatDate(retrievedUser.date)}`}\n            </p>\n          </div>\n        )}\n      </div>\n    </div>\n  );\n};\n","import React from 'react';\n// import { Can } from 'react-rb-auth';\n\nimport { Login } from './Login';\nimport { Logout } from './Profile';\nimport { AppAuthContext } from '../services/AppAuthContext';\n\nexport const LoginLogout: React.FC = () => (\n  // <Can role=\"admin\" perform=\"dashboard-page:visit\" yes={() => <Logout />} no={() => <Login />} />\n  <AppAuthContext.Consumer>\n    {(auth) => (\n      <>\n        {auth.isAuth && <Logout />}\n        {!auth.isAuth && <Login />}\n      </>\n    )}\n  </AppAuthContext.Consumer>\n);\n","import React from 'react';\nimport { useLocation } from 'react-router-dom';\nimport { RefreshApp } from 'react-rb-auth';\n\nexport const BrowserRefresh: React.FC<{\n  AuthReloadingComp: React.FC;\n  authCallbackRoute?: string;\n}> = ({ children, AuthReloadingComp, authCallbackRoute }) => {\n  const location = useLocation();\n  return (\n    <RefreshApp\n      locationPathName={location.pathname}\n      AuthReloadingComp={AuthReloadingComp}\n      authCallbackRoute={authCallbackRoute}\n    >\n      {children}\n    </RefreshApp>\n  );\n};\n","import React from 'react';\nimport { Redirect, Route } from 'react-router-dom';\nimport { SecureScreen, RBAuthRedirect } from 'react-rb-auth';\n\n/**\n * AppRedirect\n * Needed to wrap react-router-dom component\n */\nconst AppRedirect: RBAuthRedirect = ({ to }) => <Redirect to={to} />;\n\nexport const SecureRoute: React.FC<{\n  path: string;\n  Allowed: React.FC;\n  NotAllowed?: React.FC;\n}> = ({ path, Allowed, NotAllowed }) => (\n  <Route\n    to={path}\n    render={() => <SecureScreen Allowed={Allowed} Redirect={AppRedirect} NotAllowed={NotAllowed} />}\n  />\n);\n","import React from 'react';\nimport { Switch, Link } from 'react-router-dom';\n\nimport { Example } from './components/Example';\nimport { SecondExample } from './components/SecondExample';\nimport { LoginLogout } from './components/LoginLogout';\nimport { BrowserRefresh } from './services/BrowserRefresh';\nimport { SecureRoute } from './services/SecureRoute';\n\nconst Reloading: React.FC = () => (\n  <div>\n    <h3>Reloading...</h3>\n    <br />\n    <br />\n  </div>\n);\n\nconst AppMenu: React.FC = ({ children }) => <div className=\"appMenu\">{children}</div>;\nconst AppLink: React.FC<{ to: string; label: string }> = ({ to, label }) => (\n  <div className=\"appLink\">\n    <Link to={to}>{label}</Link>\n  </div>\n);\n\nexport const App: React.FC = () => (\n  <>\n    <Example />\n    <div className=\"Example appBounding\">\n      <AppMenu>\n        <AppLink to=\"/\" label=\"Home\" />\n        <AppLink to=\"/secure\" label=\"Secure\" />\n        <AppLink to=\"/super-secure\" label=\"Super Secure\" />\n      </AppMenu>\n      <BrowserRefresh AuthReloadingComp={Reloading}>\n        <Switch>\n          <SecureRoute\n            path=\"/secure\"\n            Allowed={() => <h3>Secure area</h3>}\n            NotAllowed={() => <h3>You are not allowed</h3>}\n          />\n\n          <SecureRoute path=\"/super-secure\" Allowed={() => <h3>Super Secure area</h3>} />\n        </Switch>\n        <LoginLogout />\n      </BrowserRefresh>\n    </div>\n\n    <SecondExample />\n  </>\n);\n","import { RBAuthUserModelWithRole } from 'react-rb-auth';\nimport { AppRole } from './role';\n\nexport interface UserModel extends RBAuthUserModelWithRole<AppRole> {\n  nickname: string;\n  name: string;\n  role: AppRole;\n  picture: string;\n  sub: string;\n  updated_at: Date;\n}\n\nexport const anonUser: UserModel = {\n  nickname: 'anon',\n  name: '',\n  role: 'public',\n  picture:\n    'https://s.gravatar.com/avatar/af17b538f2e14a4a5c4a23799233af63?s=480&r=pg&d=https%3A%2F%2Fcdn.auth0.com%2Favatars%2Fnu.png',\n  sub: '',\n  updated_at: new Date(),\n};\n","import { RBAuthErrors } from 'react-rb-auth';\nimport {\n  RBAuthTokensType,\n  HeadersBuilder,\n  RequestBuilder,\n  HTTPMethod,\n  TokenUtil,\n} from 'react-rb-auth';\n\nconst AUTH0_DOMAIN = process.env.REACT_APP_AUTH0_DOMAIN;\nconst AUTH0_CLIENT_ID = process.env.REACT_APP_AUTH0_CLIENT_ID;\nconst AUTH0_AUDIENCE = process.env.REACT_APP_AUTH0_AUDIENCE;\n\ninterface AuthError {\n  error: string;\n  error_description: string;\n}\n\ntype RawTokensType = {\n  access_token: string;\n  refresh_token: string;\n  id_token: string;\n  expires_in: string;\n  scope: string;\n  token_type: string;\n};\n\nexport class Auth0Api {\n  private static connection = 'Username-Password-Authentication';\n  // openid for id token\n  // offline_access for refresh token\n  private static scope = 'profile openid offline_access';\n\n  private static auth0body = { client_id: AUTH0_CLIENT_ID, audience: AUTH0_AUDIENCE };\n\n  static mapTokens(rawTokens: RawTokensType): RBAuthTokensType {\n    return {\n      accessToken: rawTokens.access_token,\n      refreshToken: rawTokens.refresh_token,\n      openIdToken: rawTokens.id_token,\n      scope: rawTokens.scope,\n      expiresIn: rawTokens.expires_in,\n      tokenType: rawTokens.token_type,\n    };\n  }\n\n  static authorize = (username: string, password: string): Promise<RawTokensType> =>\n    new RequestBuilder(`https://${AUTH0_DOMAIN}/oauth/token`)\n      .withMethod(HTTPMethod.POST)\n      .withHeaders(new HeadersBuilder().withContentTypeJson().build())\n      .withAuth0Body({\n        ...Auth0Api.auth0body,\n        connection: Auth0Api.connection,\n        scope: Auth0Api.scope,\n        grant_type: 'password',\n        username,\n        password,\n      })\n      .withErrorHandling<AuthError>((res) => {\n        if (res.error) throw Error(res.error);\n      })\n      .build();\n\n  // api docs: https://auth0.com/docs/api/authentication#revoke-refresh-token\n  static refresh = async (\n    refreshToken: string = TokenUtil.getTokens().refreshToken\n  ): Promise<RBAuthTokensType> => {\n    if (!refreshToken || refreshToken === '') throw new Error('noRefreshToken');\n    const res = await new RequestBuilder(`https://${AUTH0_DOMAIN}/oauth/token`)\n      .withMethod(HTTPMethod.POST)\n      .withHeaders(new HeadersBuilder().withContentTypeJson().build())\n      .withBody({\n        grant_type: 'refresh_token',\n        client_id: AUTH0_CLIENT_ID,\n        refresh_token: refreshToken,\n      })\n      .withErrorHandling<AuthError>((res) => {\n        if (res.error) {\n          // eslint-disable-next-line no-console\n          console.log('Auth0Api::refresh result.error: ', res.error);\n          if (res.error === 'invalid_grant') throw Error(RBAuthErrors.INVALID_GRANT);\n        }\n      })\n      .build<RawTokensType>();\n\n    return Auth0Api.mapTokens(res);\n  };\n\n  // https://auth0.com/docs/logout\n  // await Auth0Api.revoke();\n  static logout = async () =>\n    new RequestBuilder(`https://${AUTH0_DOMAIN}/v2/logout`).withMode('no-cors').build();\n\n  static revoke = (tokens: RBAuthTokensType = TokenUtil.getTokens()) =>\n    tokens.refreshToken &&\n    new RequestBuilder(`https://${AUTH0_DOMAIN}/oauth/revoke`, true)\n      .withMethod(HTTPMethod.POST)\n      .withBody({\n        client_id: AUTH0_CLIENT_ID,\n        client_secret: 'gCZVMcdV2q9n7G7jjnZrYEwee1FdAOGV7-b7AnMhJZIzAIGBE6Fb4LMTeIr0XIn0',\n        token: tokens.refreshToken,\n      })\n      .withHeaders(new HeadersBuilder().withContentTypeJson().build())\n      .withMode('no-cors')\n      .withErrorHandling<AuthError>((res) => {\n        if (res.error) throw Error(res.error);\n      })\n      .build();\n\n  static signup = (name: string, email: string, password: string) =>\n    new RequestBuilder(`https://${AUTH0_DOMAIN}/dbconnections/signup`)\n      .withMethod(HTTPMethod.POST)\n      .withHeaders(new HeadersBuilder().withContentTypeJson().build())\n      .withAuth0Body({\n        ...Auth0Api.auth0body,\n        connection: Auth0Api.connection,\n        scope: Auth0Api.scope,\n        grant_type: 'password',\n        device: 'mydevice',\n        email,\n        name,\n        password,\n      })\n      .withErrorHandling<AuthError>((res) => {\n        if (res.error) throw Error(res.error);\n      })\n      .build();\n\n  static getUser = <U>(tokenType: string, accessToken: string): Promise<U> =>\n    new RequestBuilder(`https://${AUTH0_DOMAIN}/userinfo`)\n      .withMethod(HTTPMethod.GET)\n      .withHeaders(new HeadersBuilder().withToken(tokenType, accessToken).build())\n      .withErrorHandling<AuthError>((res) => {\n        if (res.error) throw Error(res.error);\n      })\n      .build();\n\n  static getUserInfo = <U>(\n    tokenType: string,\n    accessToken: string,\n    userAuth0Id: string\n  ): Promise<U> =>\n    new RequestBuilder(`https://${AUTH0_DOMAIN}/api/v2/users/${userAuth0Id}`)\n      .withMethod(HTTPMethod.GET)\n      .withHeaders(\n        new HeadersBuilder().withToken(tokenType, accessToken).withContentTypeJson().build()\n      )\n      .withErrorHandling<AuthError>((res) => {\n        if (res.error) throw Error(res.error);\n      })\n      .build();\n}\n","import {\n  PartialAuthApi,\n  RBAuthTokensType,\n  RBAuthUserModelWithRole,\n  RBAuthBaseRoles\n} from 'react-rb-auth'\n\nimport { anonUser } from '../models/user'\nimport { Auth0Api } from './Auth0Api'\nimport { AppRole } from '../models/role'\n\ntype AuthResObj<U = RBAuthUserModelWithRole<RBAuthBaseRoles>> = {\n  tokens: RBAuthTokensType\n  user: U\n}\ntype UserInfoApiType = {\n  user_metadata: {\n    role: AppRole\n  }\n}\ntype UserApiType<U> = {\n  nickname: string\n  sub: string\n} & U\n\nexport type LoginType = <U extends RBAuthUserModelWithRole<RBAuthBaseRoles>>(\n  email: string,\n  password: string\n) => Promise<AuthResObj<U>>\nexport type SilentType = () => Promise<AuthResObj>\nexport type HandleType = () => Promise<AuthResObj>\nexport type LogoutType = () => Promise<unknown>\nexport type SignupType = (\n  name: string,\n  email: string,\n  password: string\n) => Promise<unknown>\nexport type RefreshType = <T>() => Promise<T>\n\n// TODO: test handle (web based only)\nexport class AuthApi implements PartialAuthApi {\n  static login: LoginType = async (username: string, password: string) =>\n    AuthApi.authWrapper(async () =>\n      Auth0Api.mapTokens(await Auth0Api.authorize(username, password))\n    )\n\n  static silent: SilentType = async () =>\n    AuthApi.authWrapper(async () => AuthApi.refresh())\n  static logout = () => Auth0Api.logout()\n  static signup: SignupType = (name, email, password) =>\n    Auth0Api.signup(name, email, password)\n  static refresh = () => Auth0Api.refresh()\n\n  /**\n   * Helpers\n   */\n  private static authWrapper = async <\n    U extends RBAuthUserModelWithRole<RBAuthBaseRoles>\n  >(\n    getTokens: () => Promise<RBAuthTokensType>\n  ): Promise<{\n    user: U\n    tokens: RBAuthTokensType\n  }> => {\n    try {\n      const t = await getTokens()\n      const user = await Auth0Api.getUser<UserApiType<U>>(\n        t.tokenType,\n        t.accessToken\n      )\n      // eslint-disable-next-line no-console\n      console.log('user: ', user)\n\n      // get role\n      const userInfo = await Auth0Api.getUserInfo<UserInfoApiType>(\n        t.tokenType,\n        t.accessToken,\n        user.sub\n      )\n      // eslint-disable-next-line no-console\n      console.log('userInfo: ', userInfo)\n      // TODO: if needed, we can all stuff to the user console.log('userInfo: ', userInfo);\n      let role = anonUser.role\n      if (userInfo && userInfo.user_metadata && userInfo.user_metadata.role)\n        role = userInfo.user_metadata.role\n      return {\n        tokens: t,\n        user: {\n          ...(user || anonUser),\n          role\n        } as U\n      }\n    } catch (error) {\n      // eslint-disable-next-line no-console\n      console.log('authWrapper catch: ', error)\n      const newUser: U = anonUser as unknown as U\n      return {\n        tokens: {\n          accessToken: '',\n          refreshToken: '',\n          openIdToken: '',\n          expiresIn: '',\n          scope: '',\n          tokenType: ''\n        },\n        user: newUser\n      }\n    }\n  }\n}\n","import { RequestBuilder, HeadersBuilder, HTTPMethod } from 'react-rb-auth'\n\nconst AUTH0_DOMAIN = process.env.REACT_APP_AUTH0_DOMAIN\n\nclass ExternalApi {\n  getUser = <T>(): Promise<T> =>\n    new RequestBuilder(`https://${AUTH0_DOMAIN}/userinfo`)\n      .withMethod(HTTPMethod.GET)\n      .withHeaders(new HeadersBuilder().withRBAuthToken().build())\n      .build()\n}\n\nexport interface GlobalApiApiI extends Record<string, any> {\n  external: ExternalApi\n}\n\nexport const GlobalAppApi: GlobalApiApiI = {\n  external: new ExternalApi(),\n}\n","/* eslint-disable no-console */\nimport { RBAuthStorageType, TokenUtil, RBAuthTokensType } from 'react-rb-auth';\n\nconst TOKENS_KEY = 'react_rb_auth_tokens';\n\nexport class AppStorage implements RBAuthStorageType {\n  tokensKey: string;\n  accessToken = '';\n  refreshToken = '';\n  openIdToken = '';\n  tokenType = '';\n  expiresIn = '';\n  scope = '';\n\n  constructor(setInitiated: (flag: boolean) => void, tokensKey: string = TOKENS_KEY) {\n    this.tokensKey = tokensKey;\n    this.init(setInitiated);\n  }\n\n  private async init(setInitiated: (flag: boolean) => void) {\n    this.loadTokensFromStorage().then(() => setInitiated(true));\n  }\n\n  private async loadTokensFromStorage() {\n    const rawTokens = localStorage.getItem(this.tokensKey);\n    if (rawTokens && rawTokens.length > 0) {\n      const tokens: RBAuthTokensType = JSON.parse(rawTokens);\n      console.log('AppStorage::loadTokensFromStorage tokens => ', tokens.refreshToken);\n      // we only save refresh token :)\n      this.refreshToken = tokens.refreshToken;\n      this.accessToken = tokens.accessToken;\n      this.openIdToken = tokens.openIdToken;\n      this.expiresIn = tokens.expiresIn;\n      this.scope = tokens.scope;\n      this.tokenType = tokens.tokenType;\n    }\n\n    TokenUtil.setStorage(this);\n  }\n\n  async setTokens(tokens: RBAuthTokensType) {\n    if (tokens.accessToken) this.accessToken = tokens.accessToken;\n    if (tokens.expiresIn) this.expiresIn = tokens.expiresIn;\n    if (tokens.openIdToken) this.openIdToken = tokens.openIdToken;\n    if (tokens.tokenType) this.tokenType = tokens.tokenType;\n    if (tokens.scope) this.scope = tokens.scope;\n    if (tokens.refreshToken) this.refreshToken = tokens.refreshToken;\n\n    try {\n      // saving is up to you but you should only save what you need\n      const valueToSave = {\n        refreshToken: tokens.refreshToken,\n      };\n      this.setItem(this.tokensKey, valueToSave);\n    } catch (e) {\n      console.log('error while saving to your storage: ', e);\n    }\n  }\n\n  setItem = async (key: string, value: Record<string, string> = {}) => {\n    // console.log('setting item: ', key, value);\n    if (key && value) return localStorage.setItem(key, JSON.stringify(value));\n    else return;\n  };\n}\n","import React, { useEffect, useState } from 'react'\nimport { Auth, TokenUtil, RefreshApp, RBAuthErrors } from 'react-rb-auth'\n\nimport { App } from './App'\nimport { AuthApi } from './services/AuthApi'\nimport { GlobalAppApi } from './services/ExternalApi'\nimport { AppStorage } from './services/AppLocalStorage'\n\nconst AuthReloading: React.FC = () => (\n  <Spinner>\n    <h3>AuthReloading</h3>\n  </Spinner>\n)\nconst AuthLoading: React.FC = () => (\n  <Spinner>\n    <h3>AuthLoading</h3>\n  </Spinner>\n)\nconst Spinner: React.FC = ({ children }) => (\n  <div\n    style={{\n      position: 'absolute',\n      display: 'flex',\n      top: 0,\n      bottom: 0,\n      left: 0,\n      right: 0,\n      backgroundColor: 'white',\n    }}\n  >\n    <div style={{ display: 'flex', flex: 1, justifyContent: 'center', alignItems: 'center' }}>\n      {children}\n    </div>\n  </div>\n)\n\nexport const Main: React.FC = () => {\n  const [initiated, setInitiated] = useState(false)\n\n  useEffect(() => {\n    TokenUtil.setStorage(new AppStorage(setInitiated))\n  }, [])\n\n  useEffect(() => {\n    // eslint-disable-next-line no-console\n    console.log('is initiated: ', initiated)\n  }, [initiated])\n\n  const onAuthExpired = (errorMsg: RBAuthErrors, error?: Error) =>\n    setTimeout(() => {\n      alert(errorMsg)\n      // eslint-disable-next-line no-console\n      error && console.log(error)\n    })\n\n  if (!initiated) return <></>\n\n  return (\n    <Auth\n      authApi={AuthApi}\n      routes={{ private: '/super-secure', public: '/' }}\n      onAuthExpired={onAuthExpired}\n      appApis={GlobalAppApi}\n    >\n      <RefreshApp\n        locationPathName={'none'}\n        AuthReloadingComp={AuthReloading}\n        AuthLoadingComp={AuthLoading}\n      >\n        <App />\n      </RefreshApp>\n    </Auth>\n  )\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport { BrowserRouter } from 'react-router-dom';\n\nimport * as serviceWorker from './serviceWorker';\nimport './index.css';\nimport { Main } from './Main';\n\nReactDOM.render(\n  <BrowserRouter>\n    <Main />\n  </BrowserRouter>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}